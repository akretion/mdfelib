#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Mar 20 04:00:47 2018 by generateDS.py version 2.28b.
# Python 3.5.2 (default, Sep 14 2017, 22:51:06)  [GCC 5.4.0 20160609]
#
# Command line options:
#   ('--no-process-includes', '')
#   ('-o', 'mdfelib/v3_00/mdfeTiposBasico.py')
#
# Command line arguments:
#   schemas/v3_00/mdfeTiposBasico_v3.00.xsd
#
# Command line:
#   /usr/local/bin/generateDS --no-process-includes -o "mdfelib/v3_00/mdfeTiposBasico.py" schemas/v3_00/mdfeTiposBasico_v3.00.xsd
#
# Current working directory (os.getcwd()):
#   mdfelib
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class TMDFe(GeneratedsSuper):
    """Tipo Manifesto de Documentos Fiscais Eletrônicos"""
    subclass = None
    superclass = None
    def __init__(self, infMDFe=None, Signature=None):
        self.original_tagname_ = None
        self.infMDFe = infMDFe
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TMDFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TMDFe.subclass:
            return TMDFe.subclass(*args_, **kwargs_)
        else:
            return TMDFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infMDFe(self): return self.infMDFe
    def set_infMDFe(self, infMDFe): self.infMDFe = infMDFe
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def hasContent_(self):
        if (
            self.infMDFe is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TMDFe', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TMDFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TMDFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TMDFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TMDFe'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TMDFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infMDFe is not None:
            self.infMDFe.export(outfile, level, namespace_, name_='infMDFe', pretty_print=pretty_print)
        if self.Signature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSignature>%s</%sSignature>%s' % ('ds:', self.gds_encode(self.gds_format_string(quote_xml(self.Signature), input_name='Signature')), 'ds:', eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infMDFe':
            obj_ = infMDFe.factory()
            obj_.build(child_)
            self.infMDFe = obj_
            obj_.original_tagname_ = 'infMDFe'
        elif nodeName_ == 'Signature':
            Signature_ = child_.text
            Signature_ = self.gds_validate_string(Signature_, node, 'Signature')
            self.Signature = Signature_
# end class TMDFe


class infMDFe(GeneratedsSuper):
    """ Informações do MDF-eVersão do leiauteEx: "3.00"Identificador da tag
    a ser assinadaInformar a chave de acesso do MDF-e e precedida do
    literal "MDFe" """
    subclass = None
    superclass = None
    def __init__(self, versao=None, Id=None, ide=None, emit=None, infModal=None, infDoc=None, seg=None, tot=None, lacres=None, autXML=None, infAdic=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.Id = _cast(None, Id)
        self.ide = ide
        self.emit = emit
        self.infModal = infModal
        self.infDoc = infDoc
        if seg is None:
            self.seg = []
        else:
            self.seg = seg
        self.tot = tot
        if lacres is None:
            self.lacres = []
        else:
            self.lacres = lacres
        if autXML is None:
            self.autXML = []
        else:
            self.autXML = autXML
        self.infAdic = infAdic
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infMDFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infMDFe.subclass:
            return infMDFe.subclass(*args_, **kwargs_)
        else:
            return infMDFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ide(self): return self.ide
    def set_ide(self, ide): self.ide = ide
    def get_emit(self): return self.emit
    def set_emit(self, emit): self.emit = emit
    def get_infModal(self): return self.infModal
    def set_infModal(self, infModal): self.infModal = infModal
    def get_infDoc(self): return self.infDoc
    def set_infDoc(self, infDoc): self.infDoc = infDoc
    def get_seg(self): return self.seg
    def set_seg(self, seg): self.seg = seg
    def add_seg(self, value): self.seg.append(value)
    def insert_seg_at(self, index, value): self.seg.insert(index, value)
    def replace_seg_at(self, index, value): self.seg[index] = value
    def get_tot(self): return self.tot
    def set_tot(self, tot): self.tot = tot
    def get_lacres(self): return self.lacres
    def set_lacres(self, lacres): self.lacres = lacres
    def add_lacres(self, value): self.lacres.append(value)
    def insert_lacres_at(self, index, value): self.lacres.insert(index, value)
    def replace_lacres_at(self, index, value): self.lacres[index] = value
    def get_autXML(self): return self.autXML
    def set_autXML(self, autXML): self.autXML = autXML
    def add_autXML(self, value): self.autXML.append(value)
    def insert_autXML_at(self, index, value): self.autXML.insert(index, value)
    def replace_autXML_at(self, index, value): self.autXML[index] = value
    def get_infAdic(self): return self.infAdic
    def set_infAdic(self, infAdic): self.infAdic = infAdic
    def get_versao(self): return self.versao
    def set_versao(self, versao): self.versao = versao
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def validate_TVerMDe(self, value):
        # Validate type TVerMDe, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ide is not None or
            self.emit is not None or
            self.infModal is not None or
            self.infDoc is not None or
            self.seg or
            self.tot is not None or
            self.lacres or
            self.autXML or
            self.infAdic is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infMDFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infMDFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infMDFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infMDFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infMDFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='infMDFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ide is not None:
            self.ide.export(outfile, level, namespace_, name_='ide', pretty_print=pretty_print)
        if self.emit is not None:
            self.emit.export(outfile, level, namespace_, name_='emit', pretty_print=pretty_print)
        if self.infModal is not None:
            self.infModal.export(outfile, level, namespace_, name_='infModal', pretty_print=pretty_print)
        if self.infDoc is not None:
            self.infDoc.export(outfile, level, namespace_, name_='infDoc', pretty_print=pretty_print)
        for seg_ in self.seg:
            seg_.export(outfile, level, namespace_, name_='seg', pretty_print=pretty_print)
        if self.tot is not None:
            self.tot.export(outfile, level, namespace_, name_='tot', pretty_print=pretty_print)
        for lacres_ in self.lacres:
            lacres_.export(outfile, level, namespace_, name_='lacres', pretty_print=pretty_print)
        for autXML_ in self.autXML:
            autXML_.export(outfile, level, namespace_, name_='autXML', pretty_print=pretty_print)
        if self.infAdic is not None:
            self.infAdic.export(outfile, level, namespace_, name_='infAdic', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerMDe(self.versao)    # validate type TVerMDe
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ide':
            obj_ = ide.factory()
            obj_.build(child_)
            self.ide = obj_
            obj_.original_tagname_ = 'ide'
        elif nodeName_ == 'emit':
            obj_ = emit.factory()
            obj_.build(child_)
            self.emit = obj_
            obj_.original_tagname_ = 'emit'
        elif nodeName_ == 'infModal':
            obj_ = infModal.factory()
            obj_.build(child_)
            self.infModal = obj_
            obj_.original_tagname_ = 'infModal'
        elif nodeName_ == 'infDoc':
            obj_ = infDoc.factory()
            obj_.build(child_)
            self.infDoc = obj_
            obj_.original_tagname_ = 'infDoc'
        elif nodeName_ == 'seg':
            obj_ = seg.factory()
            obj_.build(child_)
            self.seg.append(obj_)
            obj_.original_tagname_ = 'seg'
        elif nodeName_ == 'tot':
            obj_ = tot.factory()
            obj_.build(child_)
            self.tot = obj_
            obj_.original_tagname_ = 'tot'
        elif nodeName_ == 'lacres':
            obj_ = lacres.factory()
            obj_.build(child_)
            self.lacres.append(obj_)
            obj_.original_tagname_ = 'lacres'
        elif nodeName_ == 'autXML':
            obj_ = autXML.factory()
            obj_.build(child_)
            self.autXML.append(obj_)
            obj_.original_tagname_ = 'autXML'
        elif nodeName_ == 'infAdic':
            obj_ = infAdic.factory()
            obj_.build(child_)
            self.infAdic = obj_
            obj_.original_tagname_ = 'infAdic'
# end class infMDFe


class ide(GeneratedsSuper):
    """Identificação do MDF-e"""
    subclass = None
    superclass = None
    def __init__(self, cUF=None, tpAmb=None, tpEmit=None, tpTransp=None, mod=None, serie=None, nMDF=None, cMDF=None, cDV=None, modal=None, dhEmi=None, tpEmis=None, procEmi=None, verProc=None, UFIni=None, UFFim=None, infMunCarrega=None, infPercurso=None, dhIniViagem=None, indCanalVerde=None):
        self.original_tagname_ = None
        self.cUF = cUF
        self.tpAmb = tpAmb
        self.tpEmit = tpEmit
        self.tpTransp = tpTransp
        self.mod = mod
        self.serie = serie
        self.nMDF = nMDF
        self.cMDF = cMDF
        self.cDV = cDV
        self.modal = modal
        self.validate_TModalMD(self.modal)
        self.dhEmi = dhEmi
        self.tpEmis = tpEmis
        self.procEmi = procEmi
        self.verProc = verProc
        self.UFIni = UFIni
        self.UFFim = UFFim
        if infMunCarrega is None:
            self.infMunCarrega = []
        else:
            self.infMunCarrega = infMunCarrega
        if infPercurso is None:
            self.infPercurso = []
        else:
            self.infPercurso = infPercurso
        self.dhIniViagem = dhIniViagem
        self.indCanalVerde = indCanalVerde
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ide)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ide.subclass:
            return ide.subclass(*args_, **kwargs_)
        else:
            return ide(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cUF(self): return self.cUF
    def set_cUF(self, cUF): self.cUF = cUF
    def get_tpAmb(self): return self.tpAmb
    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb
    def get_tpEmit(self): return self.tpEmit
    def set_tpEmit(self, tpEmit): self.tpEmit = tpEmit
    def get_tpTransp(self): return self.tpTransp
    def set_tpTransp(self, tpTransp): self.tpTransp = tpTransp
    def get_mod(self): return self.mod
    def set_mod(self, mod): self.mod = mod
    def get_serie(self): return self.serie
    def set_serie(self, serie): self.serie = serie
    def get_nMDF(self): return self.nMDF
    def set_nMDF(self, nMDF): self.nMDF = nMDF
    def get_cMDF(self): return self.cMDF
    def set_cMDF(self, cMDF): self.cMDF = cMDF
    def get_cDV(self): return self.cDV
    def set_cDV(self, cDV): self.cDV = cDV
    def get_modal(self): return self.modal
    def set_modal(self, modal): self.modal = modal
    def get_dhEmi(self): return self.dhEmi
    def set_dhEmi(self, dhEmi): self.dhEmi = dhEmi
    def get_tpEmis(self): return self.tpEmis
    def set_tpEmis(self, tpEmis): self.tpEmis = tpEmis
    def get_procEmi(self): return self.procEmi
    def set_procEmi(self, procEmi): self.procEmi = procEmi
    def get_verProc(self): return self.verProc
    def set_verProc(self, verProc): self.verProc = verProc
    def get_UFIni(self): return self.UFIni
    def set_UFIni(self, UFIni): self.UFIni = UFIni
    def get_UFFim(self): return self.UFFim
    def set_UFFim(self, UFFim): self.UFFim = UFFim
    def get_infMunCarrega(self): return self.infMunCarrega
    def set_infMunCarrega(self, infMunCarrega): self.infMunCarrega = infMunCarrega
    def add_infMunCarrega(self, value): self.infMunCarrega.append(value)
    def insert_infMunCarrega_at(self, index, value): self.infMunCarrega.insert(index, value)
    def replace_infMunCarrega_at(self, index, value): self.infMunCarrega[index] = value
    def get_infPercurso(self): return self.infPercurso
    def set_infPercurso(self, infPercurso): self.infPercurso = infPercurso
    def add_infPercurso(self, value): self.infPercurso.append(value)
    def insert_infPercurso_at(self, index, value): self.infPercurso.insert(index, value)
    def replace_infPercurso_at(self, index, value): self.infPercurso[index] = value
    def get_dhIniViagem(self): return self.dhIniViagem
    def set_dhIniViagem(self, dhIniViagem): self.dhIniViagem = dhIniViagem
    def get_indCanalVerde(self): return self.indCanalVerde
    def set_indCanalVerde(self, indCanalVerde): self.indCanalVerde = indCanalVerde
    def validate_TModalMD(self, value):
        # Validate type TModalMD, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.cUF is not None or
            self.tpAmb is not None or
            self.tpEmit is not None or
            self.tpTransp is not None or
            self.mod is not None or
            self.serie is not None or
            self.nMDF is not None or
            self.cMDF is not None or
            self.cDV is not None or
            self.modal is not None or
            self.dhEmi is not None or
            self.tpEmis is not None or
            self.procEmi is not None or
            self.verProc is not None or
            self.UFIni is not None or
            self.UFFim is not None or
            self.infMunCarrega or
            self.infPercurso or
            self.dhIniViagem is not None or
            self.indCanalVerde is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ide', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ide')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ide')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ide', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ide'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ide', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespace_, eol_))
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespace_, eol_))
        if self.tpEmit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpEmit>%s</%stpEmit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpEmit), input_name='tpEmit')), namespace_, eol_))
        if self.tpTransp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpTransp>%s</%stpTransp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpTransp), input_name='tpTransp')), namespace_, eol_))
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespace_, eol_))
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespace_, eol_))
        if self.nMDF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snMDF>%s</%snMDF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nMDF), input_name='nMDF')), namespace_, eol_))
        if self.cMDF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMDF>%s</%scMDF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMDF), input_name='cMDF')), namespace_, eol_))
        if self.cDV is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scDV>%s</%scDV>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cDV), input_name='cDV')), namespace_, eol_))
        if self.modal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodal>%s</%smodal>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.modal), input_name='modal')), namespace_, eol_))
        if self.dhEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhEmi>%s</%sdhEmi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dhEmi), input_name='dhEmi')), namespace_, eol_))
        if self.tpEmis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpEmis>%s</%stpEmis>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpEmis), input_name='tpEmis')), namespace_, eol_))
        if self.procEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocEmi>%s</%sprocEmi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.procEmi), input_name='procEmi')), namespace_, eol_))
        if self.verProc is not None:
            self.verProc.export(outfile, level, namespace_, name_='verProc', pretty_print=pretty_print)
        if self.UFIni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFIni>%s</%sUFIni>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UFIni), input_name='UFIni')), namespace_, eol_))
        if self.UFFim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFFim>%s</%sUFFim>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UFFim), input_name='UFFim')), namespace_, eol_))
        for infMunCarrega_ in self.infMunCarrega:
            infMunCarrega_.export(outfile, level, namespace_, name_='infMunCarrega', pretty_print=pretty_print)
        for infPercurso_ in self.infPercurso:
            infPercurso_.export(outfile, level, namespace_, name_='infPercurso', pretty_print=pretty_print)
        if self.dhIniViagem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhIniViagem>%s</%sdhIniViagem>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dhIniViagem), input_name='dhIniViagem')), namespace_, eol_))
        if self.indCanalVerde is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindCanalVerde>%s</%sindCanalVerde>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.indCanalVerde), input_name='indCanalVerde')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
        elif nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
        elif nodeName_ == 'tpEmit':
            tpEmit_ = child_.text
            tpEmit_ = self.gds_validate_string(tpEmit_, node, 'tpEmit')
            self.tpEmit = tpEmit_
        elif nodeName_ == 'tpTransp':
            tpTransp_ = child_.text
            tpTransp_ = self.gds_validate_string(tpTransp_, node, 'tpTransp')
            self.tpTransp = tpTransp_
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
        elif nodeName_ == 'nMDF':
            nMDF_ = child_.text
            nMDF_ = self.gds_validate_string(nMDF_, node, 'nMDF')
            self.nMDF = nMDF_
        elif nodeName_ == 'cMDF':
            cMDF_ = child_.text
            cMDF_ = self.gds_validate_string(cMDF_, node, 'cMDF')
            self.cMDF = cMDF_
        elif nodeName_ == 'cDV':
            cDV_ = child_.text
            cDV_ = self.gds_validate_string(cDV_, node, 'cDV')
            self.cDV = cDV_
        elif nodeName_ == 'modal':
            modal_ = child_.text
            modal_ = self.gds_validate_string(modal_, node, 'modal')
            self.modal = modal_
            # validate type TModalMD
            self.validate_TModalMD(self.modal)
        elif nodeName_ == 'dhEmi':
            dhEmi_ = child_.text
            dhEmi_ = self.gds_validate_string(dhEmi_, node, 'dhEmi')
            self.dhEmi = dhEmi_
        elif nodeName_ == 'tpEmis':
            tpEmis_ = child_.text
            tpEmis_ = self.gds_validate_string(tpEmis_, node, 'tpEmis')
            self.tpEmis = tpEmis_
        elif nodeName_ == 'procEmi':
            procEmi_ = child_.text
            procEmi_ = self.gds_validate_string(procEmi_, node, 'procEmi')
            self.procEmi = procEmi_
        elif nodeName_ == 'verProc':
            obj_ = None
            self.verProc = obj_
            obj_.original_tagname_ = 'verProc'
        elif nodeName_ == 'UFIni':
            UFIni_ = child_.text
            UFIni_ = self.gds_validate_string(UFIni_, node, 'UFIni')
            self.UFIni = UFIni_
        elif nodeName_ == 'UFFim':
            UFFim_ = child_.text
            UFFim_ = self.gds_validate_string(UFFim_, node, 'UFFim')
            self.UFFim = UFFim_
        elif nodeName_ == 'infMunCarrega':
            obj_ = infMunCarrega.factory()
            obj_.build(child_)
            self.infMunCarrega.append(obj_)
            obj_.original_tagname_ = 'infMunCarrega'
        elif nodeName_ == 'infPercurso':
            obj_ = infPercurso.factory()
            obj_.build(child_)
            self.infPercurso.append(obj_)
            obj_.original_tagname_ = 'infPercurso'
        elif nodeName_ == 'dhIniViagem':
            dhIniViagem_ = child_.text
            dhIniViagem_ = self.gds_validate_string(dhIniViagem_, node, 'dhIniViagem')
            self.dhIniViagem = dhIniViagem_
        elif nodeName_ == 'indCanalVerde':
            indCanalVerde_ = child_.text
            indCanalVerde_ = self.gds_validate_string(indCanalVerde_, node, 'indCanalVerde')
            self.indCanalVerde = indCanalVerde_
# end class ide


class cMDF(GeneratedsSuper):
    """Código numérico que compõe a Chave de Acesso. Código aleatório
    gerado pelo emitente, com o objetivo de evitar acessos indevidos
    ao documento."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cMDF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cMDF.subclass:
            return cMDF.subclass(*args_, **kwargs_)
        else:
            return cMDF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cMDF', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cMDF')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cMDF')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cMDF', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cMDF'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cMDF', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cMDF


class cDV(GeneratedsSuper):
    """Digito verificador da chave de acesso do ManifestoInformar o dígito
    de controle da chave de acesso do MDF-e, que deve ser calculado
    com a aplicação do algoritmo módulo 11 (base 2,9) da chave de
    acesso."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cDV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cDV.subclass:
            return cDV.subclass(*args_, **kwargs_)
        else:
            return cDV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cDV', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cDV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cDV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cDV', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cDV'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cDV', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cDV


class tpEmis(GeneratedsSuper):
    """Forma de emissão do Manifesto (Normal ou Contingência)1 - Normal ; 2
    - Contingência"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpEmis)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpEmis.subclass:
            return tpEmis.subclass(*args_, **kwargs_)
        else:
            return tpEmis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpEmis', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpEmis')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpEmis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpEmis', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpEmis'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpEmis', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpEmis


class procEmi(GeneratedsSuper):
    """Identificação do processo de emissão do Manifesto0 - emissão de
    MDF-e com aplicativo do contribuinte; 3- emissão MDF-e pelo
    contribuinte com aplicativo fornecido pelo Fisco."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, procEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if procEmi.subclass:
            return procEmi.subclass(*args_, **kwargs_)
        else:
            return procEmi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='procEmi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('procEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='procEmi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='procEmi', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='procEmi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='procEmi', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class procEmi


class verProc(GeneratedsSuper):
    """Versão do processo de emissãoInformar a versão do aplicativo emissor
    de MDF-e."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, verProc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if verProc.subclass:
            return verProc.subclass(*args_, **kwargs_)
        else:
            return verProc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='verProc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('verProc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='verProc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='verProc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='verProc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='verProc', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class verProc


class infMunCarrega(GeneratedsSuper):
    """Informações dos Municípios de Carregamento"""
    subclass = None
    superclass = None
    def __init__(self, cMunCarrega=None, xMunCarrega=None):
        self.original_tagname_ = None
        self.cMunCarrega = cMunCarrega
        self.xMunCarrega = xMunCarrega
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infMunCarrega)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infMunCarrega.subclass:
            return infMunCarrega.subclass(*args_, **kwargs_)
        else:
            return infMunCarrega(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cMunCarrega(self): return self.cMunCarrega
    def set_cMunCarrega(self, cMunCarrega): self.cMunCarrega = cMunCarrega
    def get_xMunCarrega(self): return self.xMunCarrega
    def set_xMunCarrega(self, xMunCarrega): self.xMunCarrega = xMunCarrega
    def hasContent_(self):
        if (
            self.cMunCarrega is not None or
            self.xMunCarrega is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infMunCarrega', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infMunCarrega')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infMunCarrega')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infMunCarrega', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infMunCarrega'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infMunCarrega', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cMunCarrega is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunCarrega>%s</%scMunCarrega>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMunCarrega), input_name='cMunCarrega')), namespace_, eol_))
        if self.xMunCarrega is not None:
            self.xMunCarrega.export(outfile, level, namespace_, name_='xMunCarrega', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cMunCarrega':
            cMunCarrega_ = child_.text
            cMunCarrega_ = self.gds_validate_string(cMunCarrega_, node, 'cMunCarrega')
            self.cMunCarrega = cMunCarrega_
        elif nodeName_ == 'xMunCarrega':
            obj_ = None
            self.xMunCarrega = obj_
            obj_.original_tagname_ = 'xMunCarrega'
# end class infMunCarrega


class xMunCarrega(GeneratedsSuper):
    """Nome do Município de Carregamento"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xMunCarrega)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xMunCarrega.subclass:
            return xMunCarrega.subclass(*args_, **kwargs_)
        else:
            return xMunCarrega(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xMunCarrega', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xMunCarrega')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xMunCarrega')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xMunCarrega', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xMunCarrega'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xMunCarrega', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xMunCarrega


class infPercurso(GeneratedsSuper):
    """Informações do Percurso do MDF-e"""
    subclass = None
    superclass = None
    def __init__(self, UFPer=None):
        self.original_tagname_ = None
        self.UFPer = UFPer
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infPercurso)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infPercurso.subclass:
            return infPercurso.subclass(*args_, **kwargs_)
        else:
            return infPercurso(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UFPer(self): return self.UFPer
    def set_UFPer(self, UFPer): self.UFPer = UFPer
    def hasContent_(self):
        if (
            self.UFPer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infPercurso', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infPercurso')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infPercurso')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infPercurso', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infPercurso'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infPercurso', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UFPer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFPer>%s</%sUFPer>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UFPer), input_name='UFPer')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UFPer':
            UFPer_ = child_.text
            UFPer_ = self.gds_validate_string(UFPer_, node, 'UFPer')
            self.UFPer = UFPer_
# end class infPercurso


class indCanalVerde(GeneratedsSuper):
    """Indicador de participação do Canal Verde"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indCanalVerde)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indCanalVerde.subclass:
            return indCanalVerde.subclass(*args_, **kwargs_)
        else:
            return indCanalVerde(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indCanalVerde', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indCanalVerde')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indCanalVerde')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indCanalVerde', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indCanalVerde'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indCanalVerde', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indCanalVerde


class emit(GeneratedsSuper):
    """Identificação do Emitente do Manifesto"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, IE=None, xNome=None, xFant=None, enderEmit=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.IE = IE
        self.xNome = xNome
        self.xFant = xFant
        self.enderEmit = enderEmit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emit.subclass:
            return emit.subclass(*args_, **kwargs_)
        else:
            return emit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_IE(self): return self.IE
    def set_IE(self, IE): self.IE = IE
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_xFant(self): return self.xFant
    def set_xFant(self, xFant): self.xFant = xFant
    def get_enderEmit(self): return self.enderEmit
    def set_enderEmit(self, enderEmit): self.enderEmit = enderEmit
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.IE is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.enderEmit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='emit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='emit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='emit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='emit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='emit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.IE is not None:
            self.IE.export(outfile, level, namespace_, name_='IE', pretty_print=pretty_print)
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        if self.xFant is not None:
            self.xFant.export(outfile, level, namespace_, name_='xFant', pretty_print=pretty_print)
        if self.enderEmit is not None:
            self.enderEmit.export(outfile, level, namespace_, name_='enderEmit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'IE':
            obj_ = None
            self.IE = obj_
            obj_.original_tagname_ = 'IE'
        elif nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'xFant':
            obj_ = None
            self.xFant = obj_
            obj_.original_tagname_ = 'xFant'
        elif nodeName_ == 'enderEmit':
            obj_ = TEndeEmi.factory()
            obj_.build(child_)
            self.enderEmit = obj_
            obj_.original_tagname_ = 'enderEmit'
# end class emit


class IE(GeneratedsSuper):
    """Inscrição Estadual do emitemte"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IE.subclass:
            return IE.subclass(*args_, **kwargs_)
        else:
            return IE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IE', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IE', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IE


class xNome(GeneratedsSuper):
    """Razão social ou Nome do emitente"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xNome)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xNome.subclass:
            return xNome.subclass(*args_, **kwargs_)
        else:
            return xNome(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xNome', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xNome')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xNome')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xNome', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xNome'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xNome', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xNome


class xFant(GeneratedsSuper):
    """Nome fantasia do emitente"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xFant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xFant.subclass:
            return xFant.subclass(*args_, **kwargs_)
        else:
            return xFant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xFant', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xFant')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xFant')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xFant', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xFant'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xFant', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xFant


class infModal(GeneratedsSuper):
    """Informações do modalVersão do leiaute específico para o Modal"""
    subclass = None
    superclass = None
    def __init__(self, versaoModal=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.versaoModal = _cast(None, versaoModal)
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infModal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infModal.subclass:
            return infModal.subclass(*args_, **kwargs_)
        else:
            return infModal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_versaoModal(self): return self.versaoModal
    def set_versaoModal(self, versaoModal): self.versaoModal = versaoModal
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infModal', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infModal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infModal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infModal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infModal'):
        if self.versaoModal is not None and 'versaoModal' not in already_processed:
            already_processed.add('versaoModal')
            outfile.write(' versaoModal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.versaoModal), input_name='versaoModal')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='infModal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versaoModal', node)
        if value is not None and 'versaoModal' not in already_processed:
            already_processed.add('versaoModal')
            self.versaoModal = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'infModal')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class infModal


class infDoc(GeneratedsSuper):
    """Informações dos Documentos fiscais vinculados ao manifesto"""
    subclass = None
    superclass = None
    def __init__(self, infMunDescarga=None):
        self.original_tagname_ = None
        if infMunDescarga is None:
            self.infMunDescarga = []
        else:
            self.infMunDescarga = infMunDescarga
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infDoc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infDoc.subclass:
            return infDoc.subclass(*args_, **kwargs_)
        else:
            return infDoc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infMunDescarga(self): return self.infMunDescarga
    def set_infMunDescarga(self, infMunDescarga): self.infMunDescarga = infMunDescarga
    def add_infMunDescarga(self, value): self.infMunDescarga.append(value)
    def insert_infMunDescarga_at(self, index, value): self.infMunDescarga.insert(index, value)
    def replace_infMunDescarga_at(self, index, value): self.infMunDescarga[index] = value
    def hasContent_(self):
        if (
            self.infMunDescarga
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infDoc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infDoc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infDoc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infDoc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infDoc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infDoc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for infMunDescarga_ in self.infMunDescarga:
            infMunDescarga_.export(outfile, level, namespace_, name_='infMunDescarga', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infMunDescarga':
            obj_ = infMunDescarga.factory()
            obj_.build(child_)
            self.infMunDescarga.append(obj_)
            obj_.original_tagname_ = 'infMunDescarga'
# end class infDoc


class infMunDescarga(GeneratedsSuper):
    """Informações dos Municípios de descarregamento"""
    subclass = None
    superclass = None
    def __init__(self, cMunDescarga=None, xMunDescarga=None, infCTe=None, infNFe=None, infMDFeTransp=None):
        self.original_tagname_ = None
        self.cMunDescarga = cMunDescarga
        self.xMunDescarga = xMunDescarga
        if infCTe is None:
            self.infCTe = []
        else:
            self.infCTe = infCTe
        if infNFe is None:
            self.infNFe = []
        else:
            self.infNFe = infNFe
        if infMDFeTransp is None:
            self.infMDFeTransp = []
        else:
            self.infMDFeTransp = infMDFeTransp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infMunDescarga)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infMunDescarga.subclass:
            return infMunDescarga.subclass(*args_, **kwargs_)
        else:
            return infMunDescarga(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cMunDescarga(self): return self.cMunDescarga
    def set_cMunDescarga(self, cMunDescarga): self.cMunDescarga = cMunDescarga
    def get_xMunDescarga(self): return self.xMunDescarga
    def set_xMunDescarga(self, xMunDescarga): self.xMunDescarga = xMunDescarga
    def get_infCTe(self): return self.infCTe
    def set_infCTe(self, infCTe): self.infCTe = infCTe
    def add_infCTe(self, value): self.infCTe.append(value)
    def insert_infCTe_at(self, index, value): self.infCTe.insert(index, value)
    def replace_infCTe_at(self, index, value): self.infCTe[index] = value
    def get_infNFe(self): return self.infNFe
    def set_infNFe(self, infNFe): self.infNFe = infNFe
    def add_infNFe(self, value): self.infNFe.append(value)
    def insert_infNFe_at(self, index, value): self.infNFe.insert(index, value)
    def replace_infNFe_at(self, index, value): self.infNFe[index] = value
    def get_infMDFeTransp(self): return self.infMDFeTransp
    def set_infMDFeTransp(self, infMDFeTransp): self.infMDFeTransp = infMDFeTransp
    def add_infMDFeTransp(self, value): self.infMDFeTransp.append(value)
    def insert_infMDFeTransp_at(self, index, value): self.infMDFeTransp.insert(index, value)
    def replace_infMDFeTransp_at(self, index, value): self.infMDFeTransp[index] = value
    def hasContent_(self):
        if (
            self.cMunDescarga is not None or
            self.xMunDescarga is not None or
            self.infCTe or
            self.infNFe or
            self.infMDFeTransp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infMunDescarga', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infMunDescarga')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infMunDescarga')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infMunDescarga', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infMunDescarga'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infMunDescarga', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cMunDescarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunDescarga>%s</%scMunDescarga>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMunDescarga), input_name='cMunDescarga')), namespace_, eol_))
        if self.xMunDescarga is not None:
            self.xMunDescarga.export(outfile, level, namespace_, name_='xMunDescarga', pretty_print=pretty_print)
        for infCTe_ in self.infCTe:
            infCTe_.export(outfile, level, namespace_, name_='infCTe', pretty_print=pretty_print)
        for infNFe_ in self.infNFe:
            infNFe_.export(outfile, level, namespace_, name_='infNFe', pretty_print=pretty_print)
        for infMDFeTransp_ in self.infMDFeTransp:
            infMDFeTransp_.export(outfile, level, namespace_, name_='infMDFeTransp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cMunDescarga':
            cMunDescarga_ = child_.text
            cMunDescarga_ = self.gds_validate_string(cMunDescarga_, node, 'cMunDescarga')
            self.cMunDescarga = cMunDescarga_
        elif nodeName_ == 'xMunDescarga':
            obj_ = None
            self.xMunDescarga = obj_
            obj_.original_tagname_ = 'xMunDescarga'
        elif nodeName_ == 'infCTe':
            obj_ = infCTe.factory()
            obj_.build(child_)
            self.infCTe.append(obj_)
            obj_.original_tagname_ = 'infCTe'
        elif nodeName_ == 'infNFe':
            obj_ = infNFe.factory()
            obj_.build(child_)
            self.infNFe.append(obj_)
            obj_.original_tagname_ = 'infNFe'
        elif nodeName_ == 'infMDFeTransp':
            obj_ = infMDFeTransp.factory()
            obj_.build(child_)
            self.infMDFeTransp.append(obj_)
            obj_.original_tagname_ = 'infMDFeTransp'
# end class infMunDescarga


class xMunDescarga(GeneratedsSuper):
    """Nome do Município de Descarregamento"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xMunDescarga)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xMunDescarga.subclass:
            return xMunDescarga.subclass(*args_, **kwargs_)
        else:
            return xMunDescarga(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xMunDescarga', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xMunDescarga')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xMunDescarga')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xMunDescarga', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xMunDescarga'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xMunDescarga', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xMunDescarga


class infCTe(GeneratedsSuper):
    """Conhecimentos de Tranporte - usar este grupo quando for prestador de
    serviço de transporte"""
    subclass = None
    superclass = None
    def __init__(self, chCTe=None, SegCodBarra=None, indReentrega=None, infUnidTransp=None, peri=None):
        self.original_tagname_ = None
        self.chCTe = chCTe
        self.SegCodBarra = SegCodBarra
        self.indReentrega = indReentrega
        if infUnidTransp is None:
            self.infUnidTransp = []
        else:
            self.infUnidTransp = infUnidTransp
        if peri is None:
            self.peri = []
        else:
            self.peri = peri
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCTe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCTe.subclass:
            return infCTe.subclass(*args_, **kwargs_)
        else:
            return infCTe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chCTe(self): return self.chCTe
    def set_chCTe(self, chCTe): self.chCTe = chCTe
    def get_SegCodBarra(self): return self.SegCodBarra
    def set_SegCodBarra(self, SegCodBarra): self.SegCodBarra = SegCodBarra
    def get_indReentrega(self): return self.indReentrega
    def set_indReentrega(self, indReentrega): self.indReentrega = indReentrega
    def get_infUnidTransp(self): return self.infUnidTransp
    def set_infUnidTransp(self, infUnidTransp): self.infUnidTransp = infUnidTransp
    def add_infUnidTransp(self, value): self.infUnidTransp.append(value)
    def insert_infUnidTransp_at(self, index, value): self.infUnidTransp.insert(index, value)
    def replace_infUnidTransp_at(self, index, value): self.infUnidTransp[index] = value
    def get_peri(self): return self.peri
    def set_peri(self, peri): self.peri = peri
    def add_peri(self, value): self.peri.append(value)
    def insert_peri_at(self, index, value): self.peri.insert(index, value)
    def replace_peri_at(self, index, value): self.peri[index] = value
    def hasContent_(self):
        if (
            self.chCTe is not None or
            self.SegCodBarra is not None or
            self.indReentrega is not None or
            self.infUnidTransp or
            self.peri
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infCTe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCTe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infCTe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infCTe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infCTe'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infCTe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCTe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTe>%s</%schCTe>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.chCTe), input_name='chCTe')), namespace_, eol_))
        if self.SegCodBarra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSegCodBarra>%s</%sSegCodBarra>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SegCodBarra), input_name='SegCodBarra')), namespace_, eol_))
        if self.indReentrega is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindReentrega>%s</%sindReentrega>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.indReentrega), input_name='indReentrega')), namespace_, eol_))
        for infUnidTransp_ in self.infUnidTransp:
            infUnidTransp_.export(outfile, level, namespace_, name_='infUnidTransp', pretty_print=pretty_print)
        for peri_ in self.peri:
            peri_.export(outfile, level, namespace_, name_='peri', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chCTe':
            chCTe_ = child_.text
            chCTe_ = self.gds_validate_string(chCTe_, node, 'chCTe')
            self.chCTe = chCTe_
        elif nodeName_ == 'SegCodBarra':
            SegCodBarra_ = child_.text
            SegCodBarra_ = self.gds_validate_string(SegCodBarra_, node, 'SegCodBarra')
            self.SegCodBarra = SegCodBarra_
        elif nodeName_ == 'indReentrega':
            indReentrega_ = child_.text
            indReentrega_ = self.gds_validate_string(indReentrega_, node, 'indReentrega')
            self.indReentrega = indReentrega_
        elif nodeName_ == 'infUnidTransp':
            obj_ = TUnidadeTransp.factory()
            obj_.build(child_)
            self.infUnidTransp.append(obj_)
            obj_.original_tagname_ = 'infUnidTransp'
        elif nodeName_ == 'peri':
            obj_ = peri.factory()
            obj_.build(child_)
            self.peri.append(obj_)
            obj_.original_tagname_ = 'peri'
# end class infCTe


class indReentrega(GeneratedsSuper):
    """Indicador de Reentrega"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indReentrega)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indReentrega.subclass:
            return indReentrega.subclass(*args_, **kwargs_)
        else:
            return indReentrega(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='indReentrega', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indReentrega')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indReentrega')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='indReentrega', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='indReentrega'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='indReentrega', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class indReentrega


class peri(GeneratedsSuper):
    """Preenchido quando for transporte de produtos classificados pela ONU
    como perigosos."""
    subclass = None
    superclass = None
    def __init__(self, nONU=None, xNomeAE=None, xClaRisco=None, grEmb=None, qTotProd=None, qVolTipo=None):
        self.original_tagname_ = None
        self.nONU = nONU
        self.xNomeAE = xNomeAE
        self.xClaRisco = xClaRisco
        self.grEmb = grEmb
        self.qTotProd = qTotProd
        self.qVolTipo = qVolTipo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, peri)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if peri.subclass:
            return peri.subclass(*args_, **kwargs_)
        else:
            return peri(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nONU(self): return self.nONU
    def set_nONU(self, nONU): self.nONU = nONU
    def get_xNomeAE(self): return self.xNomeAE
    def set_xNomeAE(self, xNomeAE): self.xNomeAE = xNomeAE
    def get_xClaRisco(self): return self.xClaRisco
    def set_xClaRisco(self, xClaRisco): self.xClaRisco = xClaRisco
    def get_grEmb(self): return self.grEmb
    def set_grEmb(self, grEmb): self.grEmb = grEmb
    def get_qTotProd(self): return self.qTotProd
    def set_qTotProd(self, qTotProd): self.qTotProd = qTotProd
    def get_qVolTipo(self): return self.qVolTipo
    def set_qVolTipo(self, qVolTipo): self.qVolTipo = qVolTipo
    def hasContent_(self):
        if (
            self.nONU is not None or
            self.xNomeAE is not None or
            self.xClaRisco is not None or
            self.grEmb is not None or
            self.qTotProd is not None or
            self.qVolTipo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='peri', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('peri')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='peri')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='peri', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='peri'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='peri', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nONU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snONU>%s</%snONU>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nONU), input_name='nONU')), namespace_, eol_))
        if self.xNomeAE is not None:
            self.xNomeAE.export(outfile, level, namespace_, name_='xNomeAE', pretty_print=pretty_print)
        if self.xClaRisco is not None:
            self.xClaRisco.export(outfile, level, namespace_, name_='xClaRisco', pretty_print=pretty_print)
        if self.grEmb is not None:
            self.grEmb.export(outfile, level, namespace_, name_='grEmb', pretty_print=pretty_print)
        if self.qTotProd is not None:
            self.qTotProd.export(outfile, level, namespace_, name_='qTotProd', pretty_print=pretty_print)
        if self.qVolTipo is not None:
            self.qVolTipo.export(outfile, level, namespace_, name_='qVolTipo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nONU':
            nONU_ = child_.text
            nONU_ = self.gds_validate_string(nONU_, node, 'nONU')
            self.nONU = nONU_
        elif nodeName_ == 'xNomeAE':
            obj_ = None
            self.xNomeAE = obj_
            obj_.original_tagname_ = 'xNomeAE'
        elif nodeName_ == 'xClaRisco':
            obj_ = None
            self.xClaRisco = obj_
            obj_.original_tagname_ = 'xClaRisco'
        elif nodeName_ == 'grEmb':
            obj_ = None
            self.grEmb = obj_
            obj_.original_tagname_ = 'grEmb'
        elif nodeName_ == 'qTotProd':
            obj_ = None
            self.qTotProd = obj_
            obj_.original_tagname_ = 'qTotProd'
        elif nodeName_ == 'qVolTipo':
            obj_ = None
            self.qVolTipo = obj_
            obj_.original_tagname_ = 'qVolTipo'
# end class peri


class nONU(GeneratedsSuper):
    """Número ONU/UNVer a legislação de transporte de produtos perigosos
    aplicadas ao modal"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nONU)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nONU.subclass:
            return nONU.subclass(*args_, **kwargs_)
        else:
            return nONU(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nONU', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nONU')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nONU')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nONU', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nONU'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nONU', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nONU


class xNomeAE(GeneratedsSuper):
    """Nome apropriado para embarque do produtoVer a legislação de
    transporte de produtos perigosos aplicada ao modo de transporte"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xNomeAE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xNomeAE.subclass:
            return xNomeAE.subclass(*args_, **kwargs_)
        else:
            return xNomeAE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xNomeAE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xNomeAE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xNomeAE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xNomeAE', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xNomeAE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xNomeAE', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xNomeAE


class xClaRisco(GeneratedsSuper):
    """Classe ou subclasse/divisão, e risco subsidiário/risco secundárioVer
    a legislação de transporte de produtos perigosos aplicadas ao
    modal"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xClaRisco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xClaRisco.subclass:
            return xClaRisco.subclass(*args_, **kwargs_)
        else:
            return xClaRisco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xClaRisco', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xClaRisco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xClaRisco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xClaRisco', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xClaRisco'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xClaRisco', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xClaRisco


class grEmb(GeneratedsSuper):
    """Grupo de EmbalagemVer a legislação de transporte de produtos
    perigosos aplicadas ao modal Preenchimento obrigatório para o
    modal aéreo. A legislação para o modal rodoviário e ferroviário
    não atribui grupo de embalagem para todos os produtos, portanto
    haverá casos de não preenchimento desse campo."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, grEmb)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if grEmb.subclass:
            return grEmb.subclass(*args_, **kwargs_)
        else:
            return grEmb(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='grEmb', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('grEmb')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='grEmb')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='grEmb', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='grEmb'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='grEmb', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class grEmb


class qTotProd(GeneratedsSuper):
    """Quantidade total por produtoPreencher conforme a legislação de
    transporte de produtos perigosos aplicada ao modal"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qTotProd)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qTotProd.subclass:
            return qTotProd.subclass(*args_, **kwargs_)
        else:
            return qTotProd(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qTotProd', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qTotProd')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qTotProd')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qTotProd', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qTotProd'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='qTotProd', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qTotProd


class qVolTipo(GeneratedsSuper):
    """Quantidade e Tipo de volumesPreencher conforme a legislação de
    transporte de produtos perigosos aplicada ao modal"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qVolTipo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qVolTipo.subclass:
            return qVolTipo.subclass(*args_, **kwargs_)
        else:
            return qVolTipo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qVolTipo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qVolTipo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qVolTipo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qVolTipo', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qVolTipo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='qVolTipo', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qVolTipo


class infNFe(GeneratedsSuper):
    """Nota Fiscal Eletronica"""
    subclass = None
    superclass = None
    def __init__(self, chNFe=None, SegCodBarra=None, indReentrega=None, infUnidTransp=None, peri=None):
        self.original_tagname_ = None
        self.chNFe = chNFe
        self.SegCodBarra = SegCodBarra
        self.indReentrega = indReentrega
        if infUnidTransp is None:
            self.infUnidTransp = []
        else:
            self.infUnidTransp = infUnidTransp
        if peri is None:
            self.peri = []
        else:
            self.peri = peri
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFe.subclass:
            return infNFe.subclass(*args_, **kwargs_)
        else:
            return infNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chNFe(self): return self.chNFe
    def set_chNFe(self, chNFe): self.chNFe = chNFe
    def get_SegCodBarra(self): return self.SegCodBarra
    def set_SegCodBarra(self, SegCodBarra): self.SegCodBarra = SegCodBarra
    def get_indReentrega(self): return self.indReentrega
    def set_indReentrega(self, indReentrega): self.indReentrega = indReentrega
    def get_infUnidTransp(self): return self.infUnidTransp
    def set_infUnidTransp(self, infUnidTransp): self.infUnidTransp = infUnidTransp
    def add_infUnidTransp(self, value): self.infUnidTransp.append(value)
    def insert_infUnidTransp_at(self, index, value): self.infUnidTransp.insert(index, value)
    def replace_infUnidTransp_at(self, index, value): self.infUnidTransp[index] = value
    def get_peri(self): return self.peri
    def set_peri(self, peri): self.peri = peri
    def add_peri(self, value): self.peri.append(value)
    def insert_peri_at(self, index, value): self.peri.insert(index, value)
    def replace_peri_at(self, index, value): self.peri[index] = value
    def hasContent_(self):
        if (
            self.chNFe is not None or
            self.SegCodBarra is not None or
            self.indReentrega is not None or
            self.infUnidTransp or
            self.peri
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infNFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infNFe'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schNFe>%s</%schNFe>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.chNFe), input_name='chNFe')), namespace_, eol_))
        if self.SegCodBarra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSegCodBarra>%s</%sSegCodBarra>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.SegCodBarra), input_name='SegCodBarra')), namespace_, eol_))
        if self.indReentrega is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindReentrega>%s</%sindReentrega>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.indReentrega), input_name='indReentrega')), namespace_, eol_))
        for infUnidTransp_ in self.infUnidTransp:
            infUnidTransp_.export(outfile, level, namespace_, name_='infUnidTransp', pretty_print=pretty_print)
        for peri_ in self.peri:
            peri_.export(outfile, level, namespace_, name_='peri', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chNFe':
            chNFe_ = child_.text
            chNFe_ = self.gds_validate_string(chNFe_, node, 'chNFe')
            self.chNFe = chNFe_
        elif nodeName_ == 'SegCodBarra':
            SegCodBarra_ = child_.text
            SegCodBarra_ = self.gds_validate_string(SegCodBarra_, node, 'SegCodBarra')
            self.SegCodBarra = SegCodBarra_
        elif nodeName_ == 'indReentrega':
            indReentrega_ = child_.text
            indReentrega_ = self.gds_validate_string(indReentrega_, node, 'indReentrega')
            self.indReentrega = indReentrega_
        elif nodeName_ == 'infUnidTransp':
            obj_ = TUnidadeTransp.factory()
            obj_.build(child_)
            self.infUnidTransp.append(obj_)
            obj_.original_tagname_ = 'infUnidTransp'
        elif nodeName_ == 'peri':
            obj_ = peri.factory()
            obj_.build(child_)
            self.peri.append(obj_)
            obj_.original_tagname_ = 'peri'
# end class infNFe


class infMDFeTransp(GeneratedsSuper):
    """Manifesto Eletrônico de Documentos Fiscais. Somente para modal
    Aquaviário (vide regras MOC)"""
    subclass = None
    superclass = None
    def __init__(self, chMDFe=None, indReentrega=None, infUnidTransp=None, peri=None):
        self.original_tagname_ = None
        self.chMDFe = chMDFe
        self.indReentrega = indReentrega
        if infUnidTransp is None:
            self.infUnidTransp = []
        else:
            self.infUnidTransp = infUnidTransp
        if peri is None:
            self.peri = []
        else:
            self.peri = peri
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infMDFeTransp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infMDFeTransp.subclass:
            return infMDFeTransp.subclass(*args_, **kwargs_)
        else:
            return infMDFeTransp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chMDFe(self): return self.chMDFe
    def set_chMDFe(self, chMDFe): self.chMDFe = chMDFe
    def get_indReentrega(self): return self.indReentrega
    def set_indReentrega(self, indReentrega): self.indReentrega = indReentrega
    def get_infUnidTransp(self): return self.infUnidTransp
    def set_infUnidTransp(self, infUnidTransp): self.infUnidTransp = infUnidTransp
    def add_infUnidTransp(self, value): self.infUnidTransp.append(value)
    def insert_infUnidTransp_at(self, index, value): self.infUnidTransp.insert(index, value)
    def replace_infUnidTransp_at(self, index, value): self.infUnidTransp[index] = value
    def get_peri(self): return self.peri
    def set_peri(self, peri): self.peri = peri
    def add_peri(self, value): self.peri.append(value)
    def insert_peri_at(self, index, value): self.peri.insert(index, value)
    def replace_peri_at(self, index, value): self.peri[index] = value
    def hasContent_(self):
        if (
            self.chMDFe is not None or
            self.indReentrega is not None or
            self.infUnidTransp or
            self.peri
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infMDFeTransp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infMDFeTransp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infMDFeTransp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infMDFeTransp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infMDFeTransp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infMDFeTransp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chMDFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schMDFe>%s</%schMDFe>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.chMDFe), input_name='chMDFe')), namespace_, eol_))
        if self.indReentrega is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindReentrega>%s</%sindReentrega>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.indReentrega), input_name='indReentrega')), namespace_, eol_))
        for infUnidTransp_ in self.infUnidTransp:
            infUnidTransp_.export(outfile, level, namespace_, name_='infUnidTransp', pretty_print=pretty_print)
        for peri_ in self.peri:
            peri_.export(outfile, level, namespace_, name_='peri', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chMDFe':
            chMDFe_ = child_.text
            chMDFe_ = self.gds_validate_string(chMDFe_, node, 'chMDFe')
            self.chMDFe = chMDFe_
        elif nodeName_ == 'indReentrega':
            indReentrega_ = child_.text
            indReentrega_ = self.gds_validate_string(indReentrega_, node, 'indReentrega')
            self.indReentrega = indReentrega_
        elif nodeName_ == 'infUnidTransp':
            obj_ = TUnidadeTransp.factory()
            obj_.build(child_)
            self.infUnidTransp.append(obj_)
            obj_.original_tagname_ = 'infUnidTransp'
        elif nodeName_ == 'peri':
            obj_ = peri.factory()
            obj_.build(child_)
            self.peri.append(obj_)
            obj_.original_tagname_ = 'peri'
# end class infMDFeTransp


class seg(GeneratedsSuper):
    """Informações de Seguro da Carga"""
    subclass = None
    superclass = None
    def __init__(self, infResp=None, infSeg=None, nApol=None, nAver=None):
        self.original_tagname_ = None
        self.infResp = infResp
        self.infSeg = infSeg
        self.nApol = nApol
        if nAver is None:
            self.nAver = []
        else:
            self.nAver = nAver
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, seg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if seg.subclass:
            return seg.subclass(*args_, **kwargs_)
        else:
            return seg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infResp(self): return self.infResp
    def set_infResp(self, infResp): self.infResp = infResp
    def get_infSeg(self): return self.infSeg
    def set_infSeg(self, infSeg): self.infSeg = infSeg
    def get_nApol(self): return self.nApol
    def set_nApol(self, nApol): self.nApol = nApol
    def get_nAver(self): return self.nAver
    def set_nAver(self, nAver): self.nAver = nAver
    def add_nAver(self, value): self.nAver.append(value)
    def insert_nAver_at(self, index, value): self.nAver.insert(index, value)
    def replace_nAver_at(self, index, value): self.nAver[index] = value
    def hasContent_(self):
        if (
            self.infResp is not None or
            self.infSeg is not None or
            self.nApol is not None or
            self.nAver
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='seg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('seg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='seg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='seg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='seg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='seg', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infResp is not None:
            self.infResp.export(outfile, level, namespace_, name_='infResp', pretty_print=pretty_print)
        if self.infSeg is not None:
            self.infSeg.export(outfile, level, namespace_, name_='infSeg', pretty_print=pretty_print)
        if self.nApol is not None:
            self.nApol.export(outfile, level, namespace_, name_='nApol', pretty_print=pretty_print)
        for nAver_ in self.nAver:
            nAver_.export(outfile, level, namespace_, name_='nAver', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infResp':
            obj_ = infResp.factory()
            obj_.build(child_)
            self.infResp = obj_
            obj_.original_tagname_ = 'infResp'
        elif nodeName_ == 'infSeg':
            obj_ = infSeg.factory()
            obj_.build(child_)
            self.infSeg = obj_
            obj_.original_tagname_ = 'infSeg'
        elif nodeName_ == 'nApol':
            obj_ = None
            self.nApol = obj_
            obj_.original_tagname_ = 'nApol'
        elif nodeName_ == 'nAver':
            obj_ = None
            self.nAver.append(obj_)
            obj_.original_tagname_ = 'nAver'
# end class seg


class infResp(GeneratedsSuper):
    """Informações do responsável pelo seguro da carga"""
    subclass = None
    superclass = None
    def __init__(self, respSeg=None, CNPJ=None, CPF=None):
        self.original_tagname_ = None
        self.respSeg = respSeg
        self.CNPJ = CNPJ
        self.CPF = CPF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infResp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infResp.subclass:
            return infResp.subclass(*args_, **kwargs_)
        else:
            return infResp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_respSeg(self): return self.respSeg
    def set_respSeg(self, respSeg): self.respSeg = respSeg
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def hasContent_(self):
        if (
            self.respSeg is not None or
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infResp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infResp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infResp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infResp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infResp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infResp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.respSeg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srespSeg>%s</%srespSeg>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.respSeg), input_name='respSeg')), namespace_, eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'respSeg':
            respSeg_ = child_.text
            respSeg_ = self.gds_validate_string(respSeg_, node, 'respSeg')
            self.respSeg = respSeg_
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
# end class infResp


class respSeg(GeneratedsSuper):
    """Responsável pelo seguroPreencher com: 1- Emitente do MDF-e; 22 -
    Responsável pela contratação do serviço de transporte
    (contratante) Dados obrigatórios apenas no modal Rodoviário,
    depois da lei 11.442/07. Para os demais modais esta informação é
    opcional."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, respSeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if respSeg.subclass:
            return respSeg.subclass(*args_, **kwargs_)
        else:
            return respSeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='respSeg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('respSeg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='respSeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='respSeg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='respSeg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='respSeg', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class respSeg


class infSeg(GeneratedsSuper):
    """Informações da seguradora"""
    subclass = None
    superclass = None
    def __init__(self, xSeg=None, CNPJ=None):
        self.original_tagname_ = None
        self.xSeg = xSeg
        self.CNPJ = CNPJ
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infSeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infSeg.subclass:
            return infSeg.subclass(*args_, **kwargs_)
        else:
            return infSeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xSeg(self): return self.xSeg
    def set_xSeg(self, xSeg): self.xSeg = xSeg
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def hasContent_(self):
        if (
            self.xSeg is not None or
            self.CNPJ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infSeg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infSeg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infSeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infSeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infSeg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infSeg', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xSeg is not None:
            self.xSeg.export(outfile, level, namespace_, name_='xSeg', pretty_print=pretty_print)
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xSeg':
            obj_ = None
            self.xSeg = obj_
            obj_.original_tagname_ = 'xSeg'
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
# end class infSeg


class xSeg(GeneratedsSuper):
    """Nome da Seguradora"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xSeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xSeg.subclass:
            return xSeg.subclass(*args_, **kwargs_)
        else:
            return xSeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xSeg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xSeg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xSeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xSeg', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xSeg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xSeg', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xSeg


class nApol(GeneratedsSuper):
    """Número da ApóliceObrigatório pela lei 11.442/07 (RCTRC)"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nApol)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nApol.subclass:
            return nApol.subclass(*args_, **kwargs_)
        else:
            return nApol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nApol', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nApol')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nApol')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nApol', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nApol'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nApol', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nApol


class nAver(GeneratedsSuper):
    """Número da AverbaçãoInformar as averbações do seguro"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nAver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nAver.subclass:
            return nAver.subclass(*args_, **kwargs_)
        else:
            return nAver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nAver', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nAver')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nAver')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nAver', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nAver'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nAver', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nAver


class tot(GeneratedsSuper):
    """Totalizadores da carga transportada e seus documentos fiscais"""
    subclass = None
    superclass = None
    def __init__(self, qCTe=None, qNFe=None, qMDFe=None, vCarga=None, cUnid=None, qCarga=None):
        self.original_tagname_ = None
        self.qCTe = qCTe
        self.qNFe = qNFe
        self.qMDFe = qMDFe
        self.vCarga = vCarga
        self.cUnid = cUnid
        self.qCarga = qCarga
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tot.subclass:
            return tot.subclass(*args_, **kwargs_)
        else:
            return tot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qCTe(self): return self.qCTe
    def set_qCTe(self, qCTe): self.qCTe = qCTe
    def get_qNFe(self): return self.qNFe
    def set_qNFe(self, qNFe): self.qNFe = qNFe
    def get_qMDFe(self): return self.qMDFe
    def set_qMDFe(self, qMDFe): self.qMDFe = qMDFe
    def get_vCarga(self): return self.vCarga
    def set_vCarga(self, vCarga): self.vCarga = vCarga
    def get_cUnid(self): return self.cUnid
    def set_cUnid(self, cUnid): self.cUnid = cUnid
    def get_qCarga(self): return self.qCarga
    def set_qCarga(self, qCarga): self.qCarga = qCarga
    def hasContent_(self):
        if (
            self.qCTe is not None or
            self.qNFe is not None or
            self.qMDFe is not None or
            self.vCarga is not None or
            self.cUnid is not None or
            self.qCarga is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tot', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tot'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qCTe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqCTe>%s</%sqCTe>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.qCTe), input_name='qCTe')), namespace_, eol_))
        if self.qNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqNFe>%s</%sqNFe>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.qNFe), input_name='qNFe')), namespace_, eol_))
        if self.qMDFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqMDFe>%s</%sqMDFe>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.qMDFe), input_name='qMDFe')), namespace_, eol_))
        if self.vCarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCarga>%s</%svCarga>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vCarga), input_name='vCarga')), namespace_, eol_))
        if self.cUnid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUnid>%s</%scUnid>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cUnid), input_name='cUnid')), namespace_, eol_))
        if self.qCarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqCarga>%s</%sqCarga>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.qCarga), input_name='qCarga')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qCTe':
            qCTe_ = child_.text
            qCTe_ = self.gds_validate_string(qCTe_, node, 'qCTe')
            self.qCTe = qCTe_
        elif nodeName_ == 'qNFe':
            qNFe_ = child_.text
            qNFe_ = self.gds_validate_string(qNFe_, node, 'qNFe')
            self.qNFe = qNFe_
        elif nodeName_ == 'qMDFe':
            qMDFe_ = child_.text
            qMDFe_ = self.gds_validate_string(qMDFe_, node, 'qMDFe')
            self.qMDFe = qMDFe_
        elif nodeName_ == 'vCarga':
            vCarga_ = child_.text
            vCarga_ = self.gds_validate_string(vCarga_, node, 'vCarga')
            self.vCarga = vCarga_
        elif nodeName_ == 'cUnid':
            cUnid_ = child_.text
            cUnid_ = self.gds_validate_string(cUnid_, node, 'cUnid')
            self.cUnid = cUnid_
        elif nodeName_ == 'qCarga':
            qCarga_ = child_.text
            qCarga_ = self.gds_validate_string(qCarga_, node, 'qCarga')
            self.qCarga = qCarga_
# end class tot


class qCTe(GeneratedsSuper):
    """Quantidade total de CT-e relacionados no Manifesto"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qCTe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qCTe.subclass:
            return qCTe.subclass(*args_, **kwargs_)
        else:
            return qCTe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qCTe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qCTe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qCTe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qCTe', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qCTe'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='qCTe', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qCTe


class qNFe(GeneratedsSuper):
    """Quantidade total de NF-e relacionadas no Manifesto"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qNFe.subclass:
            return qNFe.subclass(*args_, **kwargs_)
        else:
            return qNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qNFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qNFe', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qNFe'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='qNFe', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qNFe


class qMDFe(GeneratedsSuper):
    """Quantidade total de MDF-e relacionados no Manifesto Aquaviário"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qMDFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qMDFe.subclass:
            return qMDFe.subclass(*args_, **kwargs_)
        else:
            return qMDFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qMDFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qMDFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qMDFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qMDFe', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qMDFe'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='qMDFe', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qMDFe


class cUnid(GeneratedsSuper):
    """Codigo da unidade de medida do Peso Bruto da Carga / Mercadorias
    transportadas01 – KG; 02 - TON"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cUnid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cUnid.subclass:
            return cUnid.subclass(*args_, **kwargs_)
        else:
            return cUnid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cUnid', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cUnid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cUnid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cUnid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cUnid'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cUnid', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cUnid


class lacres(GeneratedsSuper):
    """Lacres do MDF-ePreechimento opcional para os modais Rodoviário e
    Ferroviário"""
    subclass = None
    superclass = None
    def __init__(self, nLacre=None):
        self.original_tagname_ = None
        self.nLacre = nLacre
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacres)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacres.subclass:
            return lacres.subclass(*args_, **kwargs_)
        else:
            return lacres(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nLacre(self): return self.nLacre
    def set_nLacre(self, nLacre): self.nLacre = nLacre
    def hasContent_(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lacres', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacres')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lacres')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='lacres', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lacres'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='lacres', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            self.nLacre.export(outfile, level, namespace_, name_='nLacre', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLacre':
            obj_ = None
            self.nLacre = obj_
            obj_.original_tagname_ = 'nLacre'
# end class lacres


class nLacre(GeneratedsSuper):
    """número do lacre"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nLacre)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nLacre.subclass:
            return nLacre.subclass(*args_, **kwargs_)
        else:
            return nLacre(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nLacre', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nLacre')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nLacre')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nLacre', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nLacre'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nLacre', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nLacre


class autXML(GeneratedsSuper):
    """Autorizados para download do XML do DF-eInformar CNPJ ou CPF.
    Preencher os zeros não significativos."""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.CPF = CPF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, autXML)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if autXML.subclass:
            return autXML.subclass(*args_, **kwargs_)
        else:
            return autXML(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='autXML', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('autXML')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='autXML')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='autXML', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='autXML'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='autXML', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
# end class autXML


class infAdic(GeneratedsSuper):
    """Informações Adicionais"""
    subclass = None
    superclass = None
    def __init__(self, infAdFisco=None, infCpl=None):
        self.original_tagname_ = None
        self.infAdFisco = infAdFisco
        self.infCpl = infCpl
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infAdic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infAdic.subclass:
            return infAdic.subclass(*args_, **kwargs_)
        else:
            return infAdic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infAdFisco(self): return self.infAdFisco
    def set_infAdFisco(self, infAdFisco): self.infAdFisco = infAdFisco
    def get_infCpl(self): return self.infCpl
    def set_infCpl(self, infCpl): self.infCpl = infCpl
    def hasContent_(self):
        if (
            self.infAdFisco is not None or
            self.infCpl is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infAdic', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infAdic')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infAdic')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infAdic', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infAdic'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infAdic', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infAdFisco is not None:
            self.infAdFisco.export(outfile, level, namespace_, name_='infAdFisco', pretty_print=pretty_print)
        if self.infCpl is not None:
            self.infCpl.export(outfile, level, namespace_, name_='infCpl', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infAdFisco':
            obj_ = None
            self.infAdFisco = obj_
            obj_.original_tagname_ = 'infAdFisco'
        elif nodeName_ == 'infCpl':
            obj_ = None
            self.infCpl = obj_
            obj_.original_tagname_ = 'infCpl'
# end class infAdic


class infAdFisco(GeneratedsSuper):
    """Informações adicionais de interesse do FiscoNorma referenciada,
    informações complementares, etc"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infAdFisco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infAdFisco.subclass:
            return infAdFisco.subclass(*args_, **kwargs_)
        else:
            return infAdFisco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infAdFisco', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infAdFisco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infAdFisco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infAdFisco', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infAdFisco'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infAdFisco', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class infAdFisco


class infCpl(GeneratedsSuper):
    """Informações complementares de interesse do Contribuinte"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCpl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCpl.subclass:
            return infCpl.subclass(*args_, **kwargs_)
        else:
            return infCpl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infCpl', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCpl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infCpl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infCpl', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infCpl'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infCpl', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class infCpl


class TEnviMDFe(GeneratedsSuper):
    """Tipo Pedido de Concessão de Autorização de MDF-e"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, idLote=None, MDFe=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.idLote = idLote
        self.validate_TIdLote(self.idLote)
        self.MDFe = MDFe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEnviMDFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEnviMDFe.subclass:
            return TEnviMDFe.subclass(*args_, **kwargs_)
        else:
            return TEnviMDFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_idLote(self): return self.idLote
    def set_idLote(self, idLote): self.idLote = idLote
    def get_MDFe(self): return self.MDFe
    def set_MDFe(self, MDFe): self.MDFe = MDFe
    def get_versao(self): return self.versao
    def set_versao(self, versao): self.versao = versao
    def validate_TIdLote(self, value):
        # Validate type TIdLote, a restriction on xs:string.
        pass
    def validate_TVerMDe(self, value):
        # Validate type TVerMDe, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.idLote is not None or
            self.MDFe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEnviMDFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEnviMDFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEnviMDFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEnviMDFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEnviMDFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TEnviMDFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.idLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidLote>%s</%sidLote>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.idLote), input_name='idLote')), namespace_, eol_))
        if self.MDFe is not None:
            self.MDFe.export(outfile, level, namespace_, name_='MDFe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerMDe(self.versao)    # validate type TVerMDe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'idLote':
            idLote_ = child_.text
            idLote_ = self.gds_validate_string(idLote_, node, 'idLote')
            self.idLote = idLote_
            # validate type TIdLote
            self.validate_TIdLote(self.idLote)
        elif nodeName_ == 'MDFe':
            obj_ = TMDFe.factory()
            obj_.build(child_)
            self.MDFe = obj_
            obj_.original_tagname_ = 'MDFe'
# end class TEnviMDFe


class TRetEnviMDFe(GeneratedsSuper):
    """Tipo Retorno do Pedido de Concessão de Autorização do MDF-e"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, cUF=None, verAplic=None, cStat=None, xMotivo=None, infRec=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.cUF = cUF
        self.verAplic = verAplic
        self.cStat = cStat
        self.xMotivo = xMotivo
        self.infRec = infRec
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetEnviMDFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetEnviMDFe.subclass:
            return TRetEnviMDFe.subclass(*args_, **kwargs_)
        else:
            return TRetEnviMDFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpAmb(self): return self.tpAmb
    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb
    def get_cUF(self): return self.cUF
    def set_cUF(self, cUF): self.cUF = cUF
    def get_verAplic(self): return self.verAplic
    def set_verAplic(self, verAplic): self.verAplic = verAplic
    def get_cStat(self): return self.cStat
    def set_cStat(self, cStat): self.cStat = cStat
    def get_xMotivo(self): return self.xMotivo
    def set_xMotivo(self, xMotivo): self.xMotivo = xMotivo
    def get_infRec(self): return self.infRec
    def set_infRec(self, infRec): self.infRec = infRec
    def get_versao(self): return self.versao
    def set_versao(self, versao): self.versao = versao
    def validate_TVerMDe(self, value):
        # Validate type TVerMDe, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.cUF is not None or
            self.verAplic is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.infRec is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TRetEnviMDFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetEnviMDFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TRetEnviMDFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TRetEnviMDFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TRetEnviMDFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TRetEnviMDFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespace_, eol_))
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespace_, eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespace_, eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespace_, eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespace_, eol_))
        if self.infRec is not None:
            self.infRec.export(outfile, level, namespace_, name_='infRec', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerMDe(self.versao)    # validate type TVerMDe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
        elif nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
        elif nodeName_ == 'infRec':
            obj_ = infRec.factory()
            obj_.build(child_)
            self.infRec = obj_
            obj_.original_tagname_ = 'infRec'
# end class TRetEnviMDFe


class tpAmb(GeneratedsSuper):
    """Identificação do Ambiente: 1 - Produção 2 - Homologação"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpAmb)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpAmb.subclass:
            return tpAmb.subclass(*args_, **kwargs_)
        else:
            return tpAmb(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpAmb', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpAmb')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpAmb')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpAmb', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpAmb'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpAmb', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpAmb


class infRec(GeneratedsSuper):
    """Dados do Recibo do Arquivo"""
    subclass = None
    superclass = None
    def __init__(self, nRec=None, dhRecbto=None, tMed=None):
        self.original_tagname_ = None
        self.nRec = nRec
        if isinstance(dhRecbto, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dhRecbto, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dhRecbto
        self.dhRecbto = initvalue_
        self.tMed = tMed
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infRec)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infRec.subclass:
            return infRec.subclass(*args_, **kwargs_)
        else:
            return infRec(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nRec(self): return self.nRec
    def set_nRec(self, nRec): self.nRec = nRec
    def get_dhRecbto(self): return self.dhRecbto
    def set_dhRecbto(self, dhRecbto): self.dhRecbto = dhRecbto
    def get_tMed(self): return self.tMed
    def set_tMed(self, tMed): self.tMed = tMed
    def hasContent_(self):
        if (
            self.nRec is not None or
            self.dhRecbto is not None or
            self.tMed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infRec', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infRec')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infRec')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infRec', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infRec'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infRec', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snRec>%s</%snRec>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nRec), input_name='nRec')), namespace_, eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhRecbto>%s</%sdhRecbto>%s' % (namespace_, self.gds_format_datetime(self.dhRecbto, input_name='dhRecbto'), namespace_, eol_))
        if self.tMed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stMed>%s</%stMed>%s' % (namespace_, self.gds_format_integer(self.tMed, input_name='tMed'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nRec':
            nRec_ = child_.text
            nRec_ = self.gds_validate_string(nRec_, node, 'nRec')
            self.nRec = nRec_
        elif nodeName_ == 'dhRecbto':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dhRecbto = dval_
        elif nodeName_ == 'tMed':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tMed')
            self.tMed = ival_
# end class infRec


class tMed(GeneratedsSuper):
    """Tempo médio de resposta do serviço (em segundos) dos últimos 5
    minutos"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tMed)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tMed.subclass:
            return tMed.subclass(*args_, **kwargs_)
        else:
            return tMed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tMed', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tMed')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tMed')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tMed', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tMed'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tMed', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tMed


class TEndeEmi(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, fone=None, email=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.nro = nro
        self.xCpl = xCpl
        self.xBairro = xBairro
        self.cMun = cMun
        self.xMun = xMun
        self.CEP = CEP
        self.UF = UF
        self.fone = fone
        self.email = email
        self.validate_TEmail(self.email)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndeEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndeEmi.subclass:
            return TEndeEmi.subclass(*args_, **kwargs_)
        else:
            return TEndeEmi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def get_fone(self): return self.fone
    def set_fone(self, fone): self.fone = fone
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def validate_TEmail(self, value):
        # Validate type TEmail, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None or
            self.fone is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndeEmi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndeEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndeEmi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndeEmi', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndeEmi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndeEmi', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            self.xLgr.export(outfile, level, namespace_, name_='xLgr', pretty_print=pretty_print)
        if self.nro is not None:
            self.nro.export(outfile, level, namespace_, name_='nro', pretty_print=pretty_print)
        if self.xCpl is not None:
            self.xCpl.export(outfile, level, namespace_, name_='xCpl', pretty_print=pretty_print)
        if self.xBairro is not None:
            self.xBairro.export(outfile, level, namespace_, name_='xBairro', pretty_print=pretty_print)
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespace_, eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespace_, eol_))
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            obj_ = None
            self.xLgr = obj_
            obj_.original_tagname_ = 'xLgr'
        elif nodeName_ == 'nro':
            obj_ = None
            self.nro = obj_
            obj_.original_tagname_ = 'nro'
        elif nodeName_ == 'xCpl':
            obj_ = None
            self.xCpl = obj_
            obj_.original_tagname_ = 'xCpl'
        elif nodeName_ == 'xBairro':
            obj_ = None
            self.xBairro = obj_
            obj_.original_tagname_ = 'xBairro'
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            # validate type TEmail
            self.validate_TEmail(self.email)
# end class TEndeEmi


class xLgr(GeneratedsSuper):
    """Logradouro"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xLgr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xLgr.subclass:
            return xLgr.subclass(*args_, **kwargs_)
        else:
            return xLgr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xLgr', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xLgr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xLgr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xLgr', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xLgr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xLgr', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xLgr


class nro(GeneratedsSuper):
    """Número"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nro)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nro.subclass:
            return nro.subclass(*args_, **kwargs_)
        else:
            return nro(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nro', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nro')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nro')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nro', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nro'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nro', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nro


class xCpl(GeneratedsSuper):
    """Complemento"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xCpl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xCpl.subclass:
            return xCpl.subclass(*args_, **kwargs_)
        else:
            return xCpl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xCpl', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xCpl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xCpl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xCpl', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xCpl'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xCpl', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xCpl


class xBairro(GeneratedsSuper):
    """Bairro"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xBairro)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xBairro.subclass:
            return xBairro.subclass(*args_, **kwargs_)
        else:
            return xBairro(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xBairro', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xBairro')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xBairro')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xBairro', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xBairro'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xBairro', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xBairro


class xMun(GeneratedsSuper):
    """Nome do município, , informar EXTERIOR para operações com o
    exterior."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xMun)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xMun.subclass:
            return xMun.subclass(*args_, **kwargs_)
        else:
            return xMun(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xMun', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xMun')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xMun')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xMun', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xMun'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xMun', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xMun


class CEP(GeneratedsSuper):
    """CEPInformar zeros não significativos"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CEP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CEP.subclass:
            return CEP.subclass(*args_, **kwargs_)
        else:
            return CEP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CEP', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CEP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CEP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CEP', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CEP'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CEP', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CEP


class fone(GeneratedsSuper):
    """Telefone"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fone.subclass:
            return fone.subclass(*args_, **kwargs_)
        else:
            return fone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fone', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fone', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fone'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fone', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fone


class TEndereco(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, cPais=None, xPais=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.nro = nro
        self.xCpl = xCpl
        self.xBairro = xBairro
        self.cMun = cMun
        self.xMun = xMun
        self.CEP = CEP
        self.UF = UF
        self.cPais = cPais
        self.xPais = xPais
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndereco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndereco.subclass:
            return TEndereco.subclass(*args_, **kwargs_)
        else:
            return TEndereco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def get_cPais(self): return self.cPais
    def set_cPais(self, cPais): self.cPais = cPais
    def get_xPais(self): return self.xPais
    def set_xPais(self, xPais): self.xPais = xPais
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None or
            self.cPais is not None or
            self.xPais is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndereco', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndereco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndereco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndereco', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndereco'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndereco', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            self.xLgr.export(outfile, level, namespace_, name_='xLgr', pretty_print=pretty_print)
        if self.nro is not None:
            self.nro.export(outfile, level, namespace_, name_='nro', pretty_print=pretty_print)
        if self.xCpl is not None:
            self.xCpl.export(outfile, level, namespace_, name_='xCpl', pretty_print=pretty_print)
        if self.xBairro is not None:
            self.xBairro.export(outfile, level, namespace_, name_='xBairro', pretty_print=pretty_print)
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespace_, eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scPais>%s</%scPais>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), namespace_, eol_))
        if self.xPais is not None:
            self.xPais.export(outfile, level, namespace_, name_='xPais', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            obj_ = None
            self.xLgr = obj_
            obj_.original_tagname_ = 'xLgr'
        elif nodeName_ == 'nro':
            obj_ = None
            self.nro = obj_
            obj_.original_tagname_ = 'nro'
        elif nodeName_ == 'xCpl':
            obj_ = None
            self.xCpl = obj_
            obj_.original_tagname_ = 'xCpl'
        elif nodeName_ == 'xBairro':
            obj_ = None
            self.xBairro = obj_
            obj_.original_tagname_ = 'xBairro'
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
        elif nodeName_ == 'xPais':
            obj_ = None
            self.xPais = obj_
            obj_.original_tagname_ = 'xPais'
# end class TEndereco


class cPais(GeneratedsSuper):
    """Código do paísUtilizar a tabela do BACEN"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cPais)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cPais.subclass:
            return cPais.subclass(*args_, **kwargs_)
        else:
            return cPais(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cPais', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cPais')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cPais')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cPais', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cPais'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cPais', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cPais


class xPais(GeneratedsSuper):
    """Nome do país"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xPais)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xPais.subclass:
            return xPais.subclass(*args_, **kwargs_)
        else:
            return xPais(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='xPais', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xPais')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xPais')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='xPais', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='xPais'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='xPais', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xPais


class TEndernac(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.nro = nro
        self.xCpl = xCpl
        self.xBairro = xBairro
        self.cMun = cMun
        self.xMun = xMun
        self.CEP = CEP
        self.UF = UF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndernac)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndernac.subclass:
            return TEndernac.subclass(*args_, **kwargs_)
        else:
            return TEndernac(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndernac', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndernac')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndernac')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndernac', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndernac'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndernac', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            self.xLgr.export(outfile, level, namespace_, name_='xLgr', pretty_print=pretty_print)
        if self.nro is not None:
            self.nro.export(outfile, level, namespace_, name_='nro', pretty_print=pretty_print)
        if self.xCpl is not None:
            self.xCpl.export(outfile, level, namespace_, name_='xCpl', pretty_print=pretty_print)
        if self.xBairro is not None:
            self.xBairro.export(outfile, level, namespace_, name_='xBairro', pretty_print=pretty_print)
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespace_, eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            obj_ = None
            self.xLgr = obj_
            obj_.original_tagname_ = 'xLgr'
        elif nodeName_ == 'nro':
            obj_ = None
            self.nro = obj_
            obj_.original_tagname_ = 'nro'
        elif nodeName_ == 'xCpl':
            obj_ = None
            self.xCpl = obj_
            obj_.original_tagname_ = 'xCpl'
        elif nodeName_ == 'xBairro':
            obj_ = None
            self.xBairro = obj_
            obj_.original_tagname_ = 'xBairro'
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
# end class TEndernac


class TEnderFer(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.nro = nro
        self.xCpl = xCpl
        self.xBairro = xBairro
        self.cMun = cMun
        self.xMun = xMun
        self.CEP = CEP
        self.UF = UF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEnderFer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEnderFer.subclass:
            return TEnderFer.subclass(*args_, **kwargs_)
        else:
            return TEnderFer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEnderFer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEnderFer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEnderFer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEnderFer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEnderFer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEnderFer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            self.xLgr.export(outfile, level, namespace_, name_='xLgr', pretty_print=pretty_print)
        if self.nro is not None:
            self.nro.export(outfile, level, namespace_, name_='nro', pretty_print=pretty_print)
        if self.xCpl is not None:
            self.xCpl.export(outfile, level, namespace_, name_='xCpl', pretty_print=pretty_print)
        if self.xBairro is not None:
            self.xBairro.export(outfile, level, namespace_, name_='xBairro', pretty_print=pretty_print)
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespace_, eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            obj_ = None
            self.xLgr = obj_
            obj_.original_tagname_ = 'xLgr'
        elif nodeName_ == 'nro':
            obj_ = None
            self.nro = obj_
            obj_.original_tagname_ = 'nro'
        elif nodeName_ == 'xCpl':
            obj_ = None
            self.xCpl = obj_
            obj_.original_tagname_ = 'xCpl'
        elif nodeName_ == 'xBairro':
            obj_ = None
            self.xBairro = obj_
            obj_.original_tagname_ = 'xBairro'
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
# end class TEnderFer


class TEndOrg(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, cPais=None, xPais=None, fone=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.nro = nro
        self.xCpl = xCpl
        self.xBairro = xBairro
        self.cMun = cMun
        self.xMun = xMun
        self.CEP = CEP
        self.UF = UF
        self.cPais = cPais
        self.xPais = xPais
        self.fone = fone
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndOrg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndOrg.subclass:
            return TEndOrg.subclass(*args_, **kwargs_)
        else:
            return TEndOrg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def get_cPais(self): return self.cPais
    def set_cPais(self, cPais): self.cPais = cPais
    def get_xPais(self): return self.xPais
    def set_xPais(self, xPais): self.xPais = xPais
    def get_fone(self): return self.fone
    def set_fone(self, fone): self.fone = fone
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None or
            self.cPais is not None or
            self.xPais is not None or
            self.fone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndOrg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndOrg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndOrg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndOrg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndOrg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndOrg', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            self.xLgr.export(outfile, level, namespace_, name_='xLgr', pretty_print=pretty_print)
        if self.nro is not None:
            self.nro.export(outfile, level, namespace_, name_='nro', pretty_print=pretty_print)
        if self.xCpl is not None:
            self.xCpl.export(outfile, level, namespace_, name_='xCpl', pretty_print=pretty_print)
        if self.xBairro is not None:
            self.xBairro.export(outfile, level, namespace_, name_='xBairro', pretty_print=pretty_print)
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespace_, eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scPais>%s</%scPais>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), namespace_, eol_))
        if self.xPais is not None:
            self.xPais.export(outfile, level, namespace_, name_='xPais', pretty_print=pretty_print)
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            obj_ = None
            self.xLgr = obj_
            obj_.original_tagname_ = 'xLgr'
        elif nodeName_ == 'nro':
            obj_ = None
            self.nro = obj_
            obj_.original_tagname_ = 'nro'
        elif nodeName_ == 'xCpl':
            obj_ = None
            self.xCpl = obj_
            obj_.original_tagname_ = 'xCpl'
        elif nodeName_ == 'xBairro':
            obj_ = None
            self.xBairro = obj_
            obj_.original_tagname_ = 'xBairro'
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
        elif nodeName_ == 'xPais':
            obj_ = None
            self.xPais = obj_
            obj_.original_tagname_ = 'xPais'
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
# end class TEndOrg


class TLocal(GeneratedsSuper):
    """Tipo Dados do Local de Origem ou Destino"""
    subclass = None
    superclass = None
    def __init__(self, cMun=None, xMun=None, UF=None):
        self.original_tagname_ = None
        self.cMun = cMun
        self.xMun = xMun
        self.UF = UF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TLocal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TLocal.subclass:
            return TLocal.subclass(*args_, **kwargs_)
        else:
            return TLocal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def hasContent_(self):
        if (
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TLocal', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TLocal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TLocal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TLocal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TLocal'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TLocal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
# end class TLocal


class TEndReEnt(GeneratedsSuper):
    """Tipo Dados do Local de Retirada ou Entrega"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, xNome=None, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, UF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.CPF = CPF
        self.xNome = xNome
        self.xLgr = xLgr
        self.nro = nro
        self.xCpl = xCpl
        self.xBairro = xBairro
        self.cMun = cMun
        self.xMun = xMun
        self.UF = UF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndReEnt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndReEnt.subclass:
            return TEndReEnt.subclass(*args_, **kwargs_)
        else:
            return TEndReEnt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndReEnt', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndReEnt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndReEnt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndReEnt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndReEnt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndReEnt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        if self.xLgr is not None:
            self.xLgr.export(outfile, level, namespace_, name_='xLgr', pretty_print=pretty_print)
        if self.nro is not None:
            self.nro.export(outfile, level, namespace_, name_='nro', pretty_print=pretty_print)
        if self.xCpl is not None:
            self.xCpl.export(outfile, level, namespace_, name_='xCpl', pretty_print=pretty_print)
        if self.xBairro is not None:
            self.xBairro.export(outfile, level, namespace_, name_='xBairro', pretty_print=pretty_print)
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespace_, eol_))
        if self.xMun is not None:
            self.xMun.export(outfile, level, namespace_, name_='xMun', pretty_print=pretty_print)
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
        elif nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'xLgr':
            obj_ = None
            self.xLgr = obj_
            obj_.original_tagname_ = 'xLgr'
        elif nodeName_ == 'nro':
            obj_ = None
            self.nro = obj_
            obj_.original_tagname_ = 'nro'
        elif nodeName_ == 'xCpl':
            obj_ = None
            self.xCpl = obj_
            obj_.original_tagname_ = 'xCpl'
        elif nodeName_ == 'xBairro':
            obj_ = None
            self.xBairro = obj_
            obj_.original_tagname_ = 'xBairro'
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
        elif nodeName_ == 'xMun':
            obj_ = None
            self.xMun = obj_
            obj_.original_tagname_ = 'xMun'
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
# end class TEndReEnt


class TNFeNF(GeneratedsSuper):
    """Tipo de Dados das Notas Fiscais Papel e Eletrônica"""
    subclass = None
    superclass = None
    def __init__(self, infNFe=None, infNF=None):
        self.original_tagname_ = None
        self.infNFe = infNFe
        self.infNF = infNF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TNFeNF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TNFeNF.subclass:
            return TNFeNF.subclass(*args_, **kwargs_)
        else:
            return TNFeNF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infNFe(self): return self.infNFe
    def set_infNFe(self, infNFe): self.infNFe = infNFe
    def get_infNF(self): return self.infNF
    def set_infNF(self, infNF): self.infNF = infNF
    def hasContent_(self):
        if (
            self.infNFe is not None or
            self.infNF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TNFeNF', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TNFeNF')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TNFeNF')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TNFeNF', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TNFeNF'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TNFeNF', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infNFe is not None:
            self.infNFe.export(outfile, level, namespace_, name_='infNFe', pretty_print=pretty_print)
        if self.infNF is not None:
            self.infNF.export(outfile, level, namespace_, name_='infNF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infNFe':
            obj_ = infNFe.factory()
            obj_.build(child_)
            self.infNFe = obj_
            obj_.original_tagname_ = 'infNFe'
        elif nodeName_ == 'infNF':
            obj_ = infNF.factory()
            obj_.build(child_)
            self.infNF = obj_
            obj_.original_tagname_ = 'infNF'
# end class TNFeNF


class infNF(GeneratedsSuper):
    """Informações da NF mod 1 e 1A"""
    subclass = None
    superclass = None
    def __init__(self, emi=None, dest=None, serie=None, nNF=None, dEmi=None, vNF=None, PIN=None):
        self.original_tagname_ = None
        self.emi = emi
        self.dest = dest
        self.serie = serie
        self.nNF = nNF
        self.dEmi = dEmi
        self.vNF = vNF
        self.PIN = PIN
        self.validate_TPIN(self.PIN)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNF.subclass:
            return infNF.subclass(*args_, **kwargs_)
        else:
            return infNF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emi(self): return self.emi
    def set_emi(self, emi): self.emi = emi
    def get_dest(self): return self.dest
    def set_dest(self, dest): self.dest = dest
    def get_serie(self): return self.serie
    def set_serie(self, serie): self.serie = serie
    def get_nNF(self): return self.nNF
    def set_nNF(self, nNF): self.nNF = nNF
    def get_dEmi(self): return self.dEmi
    def set_dEmi(self, dEmi): self.dEmi = dEmi
    def get_vNF(self): return self.vNF
    def set_vNF(self, vNF): self.vNF = vNF
    def get_PIN(self): return self.PIN
    def set_PIN(self, PIN): self.PIN = PIN
    def validate_TPIN(self, value):
        # Validate type TPIN, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.emi is not None or
            self.dest is not None or
            self.serie is not None or
            self.nNF is not None or
            self.dEmi is not None or
            self.vNF is not None or
            self.PIN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infNF', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNF')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infNF')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infNF', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infNF'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infNF', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.emi is not None:
            self.emi.export(outfile, level, namespace_, name_='emi', pretty_print=pretty_print)
        if self.dest is not None:
            self.dest.export(outfile, level, namespace_, name_='dest', pretty_print=pretty_print)
        if self.serie is not None:
            self.serie.export(outfile, level, namespace_, name_='serie', pretty_print=pretty_print)
        if self.nNF is not None:
            self.nNF.export(outfile, level, namespace_, name_='nNF', pretty_print=pretty_print)
        if self.dEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespace_, eol_))
        if self.vNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svNF>%s</%svNF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.vNF), input_name='vNF')), namespace_, eol_))
        if self.PIN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPIN>%s</%sPIN>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.PIN), input_name='PIN')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'emi':
            obj_ = emi.factory()
            obj_.build(child_)
            self.emi = obj_
            obj_.original_tagname_ = 'emi'
        elif nodeName_ == 'dest':
            obj_ = dest.factory()
            obj_.build(child_)
            self.dest = obj_
            obj_.original_tagname_ = 'dest'
        elif nodeName_ == 'serie':
            obj_ = None
            self.serie = obj_
            obj_.original_tagname_ = 'serie'
        elif nodeName_ == 'nNF':
            obj_ = None
            self.nNF = obj_
            obj_.original_tagname_ = 'nNF'
        elif nodeName_ == 'dEmi':
            dEmi_ = child_.text
            dEmi_ = self.gds_validate_string(dEmi_, node, 'dEmi')
            self.dEmi = dEmi_
        elif nodeName_ == 'vNF':
            vNF_ = child_.text
            vNF_ = self.gds_validate_string(vNF_, node, 'vNF')
            self.vNF = vNF_
        elif nodeName_ == 'PIN':
            PIN_ = child_.text
            PIN_ = self.gds_validate_string(PIN_, node, 'PIN')
            self.PIN = PIN_
            # validate type TPIN
            self.validate_TPIN(self.PIN)
# end class infNF


class emi(GeneratedsSuper):
    """Informações do Emitente da NF"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, xNome=None, UF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.xNome = xNome
        self.UF = UF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emi.subclass:
            return emi.subclass(*args_, **kwargs_)
        else:
            return emi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.xNome is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='emi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='emi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='emi', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='emi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='emi', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
# end class emi


class dest(GeneratedsSuper):
    """Informações do Destinatário da NF"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, xNome=None, UF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.CPF = CPF
        self.xNome = xNome
        self.UF = UF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dest.subclass:
            return dest.subclass(*args_, **kwargs_)
        else:
            return dest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dest'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespace_, eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespace_, eol_))
        if self.xNome is not None:
            self.xNome.export(outfile, level, namespace_, name_='xNome', pretty_print=pretty_print)
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
        elif nodeName_ == 'xNome':
            obj_ = None
            self.xNome = obj_
            obj_.original_tagname_ = 'xNome'
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
# end class dest


class serie(GeneratedsSuper):
    """Série"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serie)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serie.subclass:
            return serie.subclass(*args_, **kwargs_)
        else:
            return serie(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='serie', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serie')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='serie')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='serie', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='serie'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='serie', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class serie


class nNF(GeneratedsSuper):
    """Número"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nNF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nNF.subclass:
            return nNF.subclass(*args_, **kwargs_)
        else:
            return nNF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nNF', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nNF')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nNF')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nNF', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nNF'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nNF', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nNF


class TUnidadeTransp(GeneratedsSuper):
    """Tipo Dados Unidade de Transporte"""
    subclass = None
    superclass = None
    def __init__(self, tpUnidTransp=None, idUnidTransp=None, lacUnidTransp=None, infUnidCarga=None, qtdRat=None):
        self.original_tagname_ = None
        self.tpUnidTransp = tpUnidTransp
        self.idUnidTransp = idUnidTransp
        self.validate_TContainer(self.idUnidTransp)
        if lacUnidTransp is None:
            self.lacUnidTransp = []
        else:
            self.lacUnidTransp = lacUnidTransp
        if infUnidCarga is None:
            self.infUnidCarga = []
        else:
            self.infUnidCarga = infUnidCarga
        self.qtdRat = qtdRat
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TUnidadeTransp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TUnidadeTransp.subclass:
            return TUnidadeTransp.subclass(*args_, **kwargs_)
        else:
            return TUnidadeTransp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpUnidTransp(self): return self.tpUnidTransp
    def set_tpUnidTransp(self, tpUnidTransp): self.tpUnidTransp = tpUnidTransp
    def get_idUnidTransp(self): return self.idUnidTransp
    def set_idUnidTransp(self, idUnidTransp): self.idUnidTransp = idUnidTransp
    def get_lacUnidTransp(self): return self.lacUnidTransp
    def set_lacUnidTransp(self, lacUnidTransp): self.lacUnidTransp = lacUnidTransp
    def add_lacUnidTransp(self, value): self.lacUnidTransp.append(value)
    def insert_lacUnidTransp_at(self, index, value): self.lacUnidTransp.insert(index, value)
    def replace_lacUnidTransp_at(self, index, value): self.lacUnidTransp[index] = value
    def get_infUnidCarga(self): return self.infUnidCarga
    def set_infUnidCarga(self, infUnidCarga): self.infUnidCarga = infUnidCarga
    def add_infUnidCarga(self, value): self.infUnidCarga.append(value)
    def insert_infUnidCarga_at(self, index, value): self.infUnidCarga.insert(index, value)
    def replace_infUnidCarga_at(self, index, value): self.infUnidCarga[index] = value
    def get_qtdRat(self): return self.qtdRat
    def set_qtdRat(self, qtdRat): self.qtdRat = qtdRat
    def validate_TContainer(self, value):
        # Validate type TContainer, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.tpUnidTransp is not None or
            self.idUnidTransp is not None or
            self.lacUnidTransp or
            self.infUnidCarga or
            self.qtdRat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TUnidadeTransp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TUnidadeTransp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TUnidadeTransp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TUnidadeTransp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TUnidadeTransp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TUnidadeTransp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpUnidTransp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpUnidTransp>%s</%stpUnidTransp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpUnidTransp), input_name='tpUnidTransp')), namespace_, eol_))
        if self.idUnidTransp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidUnidTransp>%s</%sidUnidTransp>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.idUnidTransp), input_name='idUnidTransp')), namespace_, eol_))
        for lacUnidTransp_ in self.lacUnidTransp:
            lacUnidTransp_.export(outfile, level, namespace_, name_='lacUnidTransp', pretty_print=pretty_print)
        for infUnidCarga_ in self.infUnidCarga:
            infUnidCarga_.export(outfile, level, namespace_, name_='infUnidCarga', pretty_print=pretty_print)
        if self.qtdRat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqtdRat>%s</%sqtdRat>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.qtdRat), input_name='qtdRat')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpUnidTransp':
            tpUnidTransp_ = child_.text
            tpUnidTransp_ = self.gds_validate_string(tpUnidTransp_, node, 'tpUnidTransp')
            self.tpUnidTransp = tpUnidTransp_
        elif nodeName_ == 'idUnidTransp':
            idUnidTransp_ = child_.text
            idUnidTransp_ = self.gds_validate_string(idUnidTransp_, node, 'idUnidTransp')
            self.idUnidTransp = idUnidTransp_
            # validate type TContainer
            self.validate_TContainer(self.idUnidTransp)
        elif nodeName_ == 'lacUnidTransp':
            obj_ = lacUnidTransp.factory()
            obj_.build(child_)
            self.lacUnidTransp.append(obj_)
            obj_.original_tagname_ = 'lacUnidTransp'
        elif nodeName_ == 'infUnidCarga':
            obj_ = TUnidCarga.factory()
            obj_.build(child_)
            self.infUnidCarga.append(obj_)
            obj_.original_tagname_ = 'infUnidCarga'
        elif nodeName_ == 'qtdRat':
            qtdRat_ = child_.text
            qtdRat_ = self.gds_validate_string(qtdRat_, node, 'qtdRat')
            self.qtdRat = qtdRat_
# end class TUnidadeTransp


class lacUnidTransp(GeneratedsSuper):
    """Lacres das Unidades de Transporte"""
    subclass = None
    superclass = None
    def __init__(self, nLacre=None):
        self.original_tagname_ = None
        self.nLacre = nLacre
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacUnidTransp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacUnidTransp.subclass:
            return lacUnidTransp.subclass(*args_, **kwargs_)
        else:
            return lacUnidTransp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nLacre(self): return self.nLacre
    def set_nLacre(self, nLacre): self.nLacre = nLacre
    def hasContent_(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lacUnidTransp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacUnidTransp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lacUnidTransp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='lacUnidTransp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lacUnidTransp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='lacUnidTransp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            self.nLacre.export(outfile, level, namespace_, name_='nLacre', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLacre':
            obj_ = None
            self.nLacre = obj_
            obj_.original_tagname_ = 'nLacre'
# end class lacUnidTransp


class TUnidCarga(GeneratedsSuper):
    """Tipo Dados Unidade de Carga"""
    subclass = None
    superclass = None
    def __init__(self, tpUnidCarga=None, idUnidCarga=None, lacUnidCarga=None, qtdRat=None):
        self.original_tagname_ = None
        self.tpUnidCarga = tpUnidCarga
        self.idUnidCarga = idUnidCarga
        self.validate_TContainer(self.idUnidCarga)
        if lacUnidCarga is None:
            self.lacUnidCarga = []
        else:
            self.lacUnidCarga = lacUnidCarga
        self.qtdRat = qtdRat
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TUnidCarga)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TUnidCarga.subclass:
            return TUnidCarga.subclass(*args_, **kwargs_)
        else:
            return TUnidCarga(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpUnidCarga(self): return self.tpUnidCarga
    def set_tpUnidCarga(self, tpUnidCarga): self.tpUnidCarga = tpUnidCarga
    def get_idUnidCarga(self): return self.idUnidCarga
    def set_idUnidCarga(self, idUnidCarga): self.idUnidCarga = idUnidCarga
    def get_lacUnidCarga(self): return self.lacUnidCarga
    def set_lacUnidCarga(self, lacUnidCarga): self.lacUnidCarga = lacUnidCarga
    def add_lacUnidCarga(self, value): self.lacUnidCarga.append(value)
    def insert_lacUnidCarga_at(self, index, value): self.lacUnidCarga.insert(index, value)
    def replace_lacUnidCarga_at(self, index, value): self.lacUnidCarga[index] = value
    def get_qtdRat(self): return self.qtdRat
    def set_qtdRat(self, qtdRat): self.qtdRat = qtdRat
    def validate_TContainer(self, value):
        # Validate type TContainer, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.tpUnidCarga is not None or
            self.idUnidCarga is not None or
            self.lacUnidCarga or
            self.qtdRat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TUnidCarga', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TUnidCarga')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TUnidCarga')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TUnidCarga', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TUnidCarga'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TUnidCarga', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpUnidCarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpUnidCarga>%s</%stpUnidCarga>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tpUnidCarga), input_name='tpUnidCarga')), namespace_, eol_))
        if self.idUnidCarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidUnidCarga>%s</%sidUnidCarga>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.idUnidCarga), input_name='idUnidCarga')), namespace_, eol_))
        for lacUnidCarga_ in self.lacUnidCarga:
            lacUnidCarga_.export(outfile, level, namespace_, name_='lacUnidCarga', pretty_print=pretty_print)
        if self.qtdRat is not None:
            self.qtdRat.export(outfile, level, namespace_, name_='qtdRat', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpUnidCarga':
            tpUnidCarga_ = child_.text
            tpUnidCarga_ = self.gds_validate_string(tpUnidCarga_, node, 'tpUnidCarga')
            self.tpUnidCarga = tpUnidCarga_
        elif nodeName_ == 'idUnidCarga':
            idUnidCarga_ = child_.text
            idUnidCarga_ = self.gds_validate_string(idUnidCarga_, node, 'idUnidCarga')
            self.idUnidCarga = idUnidCarga_
            # validate type TContainer
            self.validate_TContainer(self.idUnidCarga)
        elif nodeName_ == 'lacUnidCarga':
            obj_ = lacUnidCarga.factory()
            obj_.build(child_)
            self.lacUnidCarga.append(obj_)
            obj_.original_tagname_ = 'lacUnidCarga'
        elif nodeName_ == 'qtdRat':
            obj_ = None
            self.qtdRat = obj_
            obj_.original_tagname_ = 'qtdRat'
# end class TUnidCarga


class lacUnidCarga(GeneratedsSuper):
    """Lacres das Unidades de Carga"""
    subclass = None
    superclass = None
    def __init__(self, nLacre=None):
        self.original_tagname_ = None
        self.nLacre = nLacre
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacUnidCarga)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacUnidCarga.subclass:
            return lacUnidCarga.subclass(*args_, **kwargs_)
        else:
            return lacUnidCarga(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nLacre(self): return self.nLacre
    def set_nLacre(self, nLacre): self.nLacre = nLacre
    def hasContent_(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lacUnidCarga', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacUnidCarga')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lacUnidCarga')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='lacUnidCarga', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lacUnidCarga'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='lacUnidCarga', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            self.nLacre.export(outfile, level, namespace_, name_='nLacre', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLacre':
            obj_ = None
            self.nLacre = obj_
            obj_.original_tagname_ = 'nLacre'
# end class lacUnidCarga


class qtdRat(GeneratedsSuper):
    """Quantidade rateada (Peso,Volume)"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qtdRat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qtdRat.subclass:
            return qtdRat.subclass(*args_, **kwargs_)
        else:
            return qtdRat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qtdRat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qtdRat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qtdRat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qtdRat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qtdRat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='qtdRat', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qtdRat


GDSClassesMapping = {
    'MDFe': TMDFe,
    'enderEmit': TEndeEmi,
    'infUnidCarga': TUnidCarga,
    'infUnidTransp': TUnidadeTransp,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TMDFe'
        rootClass = TMDFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TMDFe'
        rootClass = TMDFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TMDFe'
        rootClass = TMDFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TMDFe'
        rootClass = TMDFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from mdfeTiposBasico import *\n\n')
        sys.stdout.write('import mdfeTiposBasico as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "TEndOrg",
    "TEndReEnt",
    "TEndeEmi",
    "TEnderFer",
    "TEndereco",
    "TEndernac",
    "TEnviMDFe",
    "TLocal",
    "TMDFe",
    "TNFeNF",
    "TRetEnviMDFe",
    "TUnidCarga",
    "TUnidadeTransp"
]
