#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu May 31 13:52:50 2018 by generateDS.py version 2.29.2.
# Python 3.6.5 (default, Apr  1 2018, 05:46:30)  [GCC 7.3.0]
#
# Command line options:
#   ('--no-namespace-defs', '')
#   ('-o', 'mdfelib/v3_00/mdfe.py')
#
# Command line arguments:
#   schemas/v3_00/mdfe_v3.00.xsd
#
# Command line:
#   /usr/local/bin/generateDS --no-namespace-defs -o "mdfelib/v3_00/mdfe.py" schemas/v3_00/mdfe_v3.00.xsd
#
# Current working directory (os.getcwd()):
#   mdfelib
#

from __future__ import unicode_literals
import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from builtins import str
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2 and not isinstance(instring, unicode):
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
                 optional=0, child_attrs=None, choice=None,
                 documentation=""):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
        self.documentation = documentation
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional
    def get_documentation(self): return self.documentation


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class TMDFe(GeneratedsSuper):
    """Tipo Manifesto de Documentos Fiscais Eletrônicos"""
    subclass = None
    superclass = None
    def __init__(self, infMDFe=None, Signature=None):
        self.original_tagname_ = None
        self.infMDFe = infMDFe
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TMDFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TMDFe.subclass:
            return TMDFe.subclass(*args_, **kwargs_)
        else:
            return TMDFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infMDFe(self): return self.infMDFe
    def set_infMDFe(self, infMDFe): self.infMDFe = infMDFe
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def hasContent_(self):
        if (
            self.infMDFe is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TMDFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TMDFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TMDFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TMDFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TMDFe'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TMDFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infMDFe is not None:
            self.infMDFe.export(outfile, level, namespace_, name_='infMDFe', pretty_print=pretty_print)
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespace_='ds:', name_='Signature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infMDFe':
            obj_ = infMDFeType.factory()
            obj_.build(child_)
            self.infMDFe = obj_
            obj_.original_tagname_ = 'infMDFe'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TMDFe


class TEnviMDFe(GeneratedsSuper):
    """Tipo Pedido de Concessão de Autorização de MDF-e"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, idLote=None, MDFe=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.idLote = idLote
        self.validate_TIdLote(self.idLote)
        self.MDFe = MDFe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEnviMDFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEnviMDFe.subclass:
            return TEnviMDFe.subclass(*args_, **kwargs_)
        else:
            return TEnviMDFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_idLote(self): return self.idLote
    def set_idLote(self, idLote): self.idLote = idLote
    def get_MDFe(self): return self.MDFe
    def set_MDFe(self, MDFe): self.MDFe = MDFe
    def get_versao(self): return self.versao
    def set_versao(self, versao): self.versao = versao
    def validate_TIdLote(self, value):
        # Validate type TIdLote, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TIdLote_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIdLote_patterns_, ))
    validate_TIdLote_patterns_ = [['^[0-9]{1,15}$']]
    def validate_TVerMDe(self, value):
        # Validate type TVerMDe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerMDe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerMDe_patterns_, ))
    validate_TVerMDe_patterns_ = [['^3\\.00$']]
    def hasContent_(self):
        if (
            self.idLote is not None or
            self.MDFe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEnviMDFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEnviMDFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEnviMDFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEnviMDFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEnviMDFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TEnviMDFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.idLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<idLote>%s</idLote>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.idLote), input_name='idLote')), eol_))
        if self.MDFe is not None:
            self.MDFe.export(outfile, level, namespace_, name_='MDFe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerMDe(self.versao)    # validate type TVerMDe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'idLote':
            idLote_ = child_.text
            idLote_ = self.gds_validate_string(idLote_, node, 'idLote')
            self.idLote = idLote_
            # validate type TIdLote
            self.validate_TIdLote(self.idLote)
        elif nodeName_ == 'MDFe':
            obj_ = TMDFe.factory()
            obj_.build(child_)
            self.MDFe = obj_
            obj_.original_tagname_ = 'MDFe'
# end class TEnviMDFe


class TRetEnviMDFe(GeneratedsSuper):
    """Tipo Retorno do Pedido de Concessão de Autorização do MDF-e"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, cUF=None, verAplic=None, cStat=None, xMotivo=None, infRec=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.infRec = infRec
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetEnviMDFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetEnviMDFe.subclass:
            return TRetEnviMDFe.subclass(*args_, **kwargs_)
        else:
            return TRetEnviMDFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpAmb(self): return self.tpAmb
    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb
    def get_cUF(self): return self.cUF
    def set_cUF(self, cUF): self.cUF = cUF
    def get_verAplic(self): return self.verAplic
    def set_verAplic(self, verAplic): self.verAplic = verAplic
    def get_cStat(self): return self.cStat
    def set_cStat(self, cStat): self.cStat = cStat
    def get_xMotivo(self): return self.xMotivo
    def set_xMotivo(self, xMotivo): self.xMotivo = xMotivo
    def get_infRec(self): return self.infRec
    def set_infRec(self, infRec): self.infRec = infRec
    def get_versao(self): return self.versao
    def set_versao(self, versao): self.versao = versao
    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : value.encode("utf-8")} )
    def validate_TVerAplic(self, value):
        # Validate type TVerAplic, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TVerAplic' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TVerAplic' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerAplic_patterns_, ))
    validate_TVerAplic_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TStat(self, value):
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TStat_patterns_, ))
    validate_TStat_patterns_ = [['^[0-9]{3}$']]
    def validate_TMotivo(self, value):
        # Validate type TMotivo, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TMotivo' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TMotivo' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TMotivo_patterns_, ))
    validate_TMotivo_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TVerMDe(self, value):
        # Validate type TVerMDe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerMDe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerMDe_patterns_, ))
    validate_TVerMDe_patterns_ = [['^3\\.00$']]
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.cUF is not None or
            self.verAplic is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.infRec is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TRetEnviMDFe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetEnviMDFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TRetEnviMDFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TRetEnviMDFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TRetEnviMDFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TRetEnviMDFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpAmb>%s</tpAmb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), eol_))
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cUF>%s</cUF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<verAplic>%s</verAplic>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cStat>%s</cStat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMotivo>%s</xMotivo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), eol_))
        if self.infRec is not None:
            self.infRec.export(outfile, level, namespace_, name_='infRec', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerMDe(self.versao)    # validate type TVerMDe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
        elif nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
        elif nodeName_ == 'infRec':
            obj_ = infRecType.factory()
            obj_.build(child_)
            self.infRec = obj_
            obj_.original_tagname_ = 'infRec'
# end class TRetEnviMDFe


class tpAmb(GeneratedsSuper):
    """Identificação do Ambiente:
    1 - Produção
    2 - Homologação"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpAmb)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpAmb.subclass:
            return tpAmb.subclass(*args_, **kwargs_)
        else:
            return tpAmb(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tpAmb', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpAmb')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tpAmb')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tpAmb', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tpAmb'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tpAmb', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tpAmb


class TEndeEmi(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, fone=None, email=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.validate_xLgrType(self.xLgr)
        self.nro = nro
        self.validate_nroType(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType(self.xMun)
        self.CEP = CEP
        self.validate_CEPType(self.CEP)
        self.UF = UF
        self.validate_TUf(self.UF)
        self.fone = fone
        self.validate_foneType(self.fone)
        self.email = email
        self.validate_TEmail(self.email)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndeEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndeEmi.subclass:
            return TEndeEmi.subclass(*args_, **kwargs_)
        else:
            return TEndeEmi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def get_fone(self): return self.fone
    def set_fone(self, fone): self.fone = fone
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def validate_xLgrType(self, value):
        # Validate type xLgrType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLgrType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLgrType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLgrType_patterns_, ))
    validate_xLgrType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nroType(self, value):
        # Validate type nroType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nroType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nroType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nroType_patterns_, ))
    validate_nroType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xCplType(self, value):
        # Validate type xCplType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCplType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCplType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCplType_patterns_, ))
    validate_xCplType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xBairroType(self, value):
        # Validate type xBairroType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xBairroType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xBairroType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xBairroType_patterns_, ))
    validate_xBairroType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_xMunType(self, value):
        # Validate type xMunType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType_patterns_, ))
    validate_xMunType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_CEPType(self, value):
        # Validate type CEPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CEPType_patterns_, ))
    validate_CEPType_patterns_ = [['^[0-9]{8}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def validate_foneType(self, value):
        # Validate type foneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_foneType_patterns_, ))
    validate_foneType_patterns_ = [['^[0-9]{7,12}$']]
    def validate_TEmail(self, value):
        # Validate type TEmail, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TEmail' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TEmail' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TEmail_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TEmail_patterns_, ))
    validate_TEmail_patterns_ = [['^[^@]+@[^\\.]+\\..+$']]
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None or
            self.fone is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndeEmi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndeEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndeEmi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndeEmi', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndeEmi'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndeEmi', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xLgr>%s</xLgr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nro>%s</nro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xCpl>%s</xCpl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xBairro>%s</xBairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMun>%s</cMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMun>%s</xMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CEP>%s</CEP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fone>%s</fone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), eol_))
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<email>%s</email>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType
            self.validate_xLgrType(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType
            self.validate_nroType(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType
            self.validate_xCplType(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType
            self.validate_xBairroType(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType
            self.validate_xMunType(self.xMun)
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
            # validate type CEPType
            self.validate_CEPType(self.CEP)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType
            self.validate_foneType(self.fone)
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            # validate type TEmail
            self.validate_TEmail(self.email)
# end class TEndeEmi


class TEndereco(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, cPais=None, xPais=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.validate_xLgrType17(self.xLgr)
        self.nro = nro
        self.validate_nroType18(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType19(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType20(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType21(self.xMun)
        self.CEP = CEP
        self.validate_CEPType22(self.CEP)
        self.UF = UF
        self.validate_TUf(self.UF)
        self.cPais = cPais
        self.validate_cPaisType(self.cPais)
        self.xPais = xPais
        self.validate_xPaisType(self.xPais)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndereco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndereco.subclass:
            return TEndereco.subclass(*args_, **kwargs_)
        else:
            return TEndereco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def get_cPais(self): return self.cPais
    def set_cPais(self, cPais): self.cPais = cPais
    def get_xPais(self): return self.xPais
    def set_xPais(self, xPais): self.xPais = xPais
    def validate_xLgrType17(self, value):
        # Validate type xLgrType17, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLgrType17' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLgrType17' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType17_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLgrType17_patterns_, ))
    validate_xLgrType17_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nroType18(self, value):
        # Validate type nroType18, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nroType18' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nroType18' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType18_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nroType18_patterns_, ))
    validate_nroType18_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xCplType19(self, value):
        # Validate type xCplType19, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCplType19' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCplType19' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType19_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCplType19_patterns_, ))
    validate_xCplType19_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xBairroType20(self, value):
        # Validate type xBairroType20, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xBairroType20' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xBairroType20' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType20_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xBairroType20_patterns_, ))
    validate_xBairroType20_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_xMunType21(self, value):
        # Validate type xMunType21, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType21' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType21' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType21_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType21_patterns_, ))
    validate_xMunType21_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_CEPType22(self, value):
        # Validate type CEPType22, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType22_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CEPType22_patterns_, ))
    validate_CEPType22_patterns_ = [['^[0-9]{8}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def validate_cPaisType(self, value):
        # Validate type cPaisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cPaisType_patterns_, ))
    validate_cPaisType_patterns_ = [['^[0-9]{1,4}$']]
    def validate_xPaisType(self, value):
        # Validate type xPaisType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xPaisType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xPaisType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xPaisType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xPaisType_patterns_, ))
    validate_xPaisType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None or
            self.cPais is not None or
            self.xPais is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndereco', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndereco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndereco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndereco', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndereco'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndereco', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xLgr>%s</xLgr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nro>%s</nro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xCpl>%s</xCpl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xBairro>%s</xBairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMun>%s</cMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMun>%s</xMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CEP>%s</CEP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cPais>%s</cPais>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), eol_))
        if self.xPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xPais>%s</xPais>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xPais), input_name='xPais')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType17
            self.validate_xLgrType17(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType18
            self.validate_nroType18(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType19
            self.validate_xCplType19(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType20
            self.validate_xBairroType20(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType21
            self.validate_xMunType21(self.xMun)
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
            # validate type CEPType22
            self.validate_CEPType22(self.CEP)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
            # validate type cPaisType
            self.validate_cPaisType(self.cPais)
        elif nodeName_ == 'xPais':
            xPais_ = child_.text
            xPais_ = self.gds_validate_string(xPais_, node, 'xPais')
            self.xPais = xPais_
            # validate type xPaisType
            self.validate_xPaisType(self.xPais)
# end class TEndereco


class TEndernac(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.validate_xLgrType23(self.xLgr)
        self.nro = nro
        self.validate_nroType24(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType25(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType26(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType27(self.xMun)
        self.CEP = CEP
        self.validate_CEPType28(self.CEP)
        self.UF = UF
        self.validate_TUf(self.UF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndernac)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndernac.subclass:
            return TEndernac.subclass(*args_, **kwargs_)
        else:
            return TEndernac(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def validate_xLgrType23(self, value):
        # Validate type xLgrType23, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLgrType23' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLgrType23' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType23_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLgrType23_patterns_, ))
    validate_xLgrType23_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nroType24(self, value):
        # Validate type nroType24, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nroType24' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nroType24' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType24_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nroType24_patterns_, ))
    validate_nroType24_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xCplType25(self, value):
        # Validate type xCplType25, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCplType25' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCplType25' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType25_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCplType25_patterns_, ))
    validate_xCplType25_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xBairroType26(self, value):
        # Validate type xBairroType26, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xBairroType26' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xBairroType26' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType26_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xBairroType26_patterns_, ))
    validate_xBairroType26_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_xMunType27(self, value):
        # Validate type xMunType27, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType27' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType27' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType27_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType27_patterns_, ))
    validate_xMunType27_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_CEPType28(self, value):
        # Validate type CEPType28, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType28_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CEPType28_patterns_, ))
    validate_CEPType28_patterns_ = [['^[0-9]{8}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndernac', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndernac')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndernac')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndernac', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndernac'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndernac', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xLgr>%s</xLgr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nro>%s</nro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xCpl>%s</xCpl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xBairro>%s</xBairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMun>%s</cMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMun>%s</xMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CEP>%s</CEP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType23
            self.validate_xLgrType23(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType24
            self.validate_nroType24(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType25
            self.validate_xCplType25(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType26
            self.validate_xBairroType26(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType27
            self.validate_xMunType27(self.xMun)
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
            # validate type CEPType28
            self.validate_CEPType28(self.CEP)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
# end class TEndernac


class TEnderFer(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.validate_xLgrType29(self.xLgr)
        self.nro = nro
        self.validate_nroType30(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType31(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType32(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType33(self.xMun)
        self.CEP = CEP
        self.validate_CEPType34(self.CEP)
        self.UF = UF
        self.validate_TUf(self.UF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEnderFer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEnderFer.subclass:
            return TEnderFer.subclass(*args_, **kwargs_)
        else:
            return TEnderFer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def validate_xLgrType29(self, value):
        # Validate type xLgrType29, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLgrType29' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLgrType29' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType29_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLgrType29_patterns_, ))
    validate_xLgrType29_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nroType30(self, value):
        # Validate type nroType30, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nroType30' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nroType30' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType30_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nroType30_patterns_, ))
    validate_nroType30_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xCplType31(self, value):
        # Validate type xCplType31, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCplType31' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCplType31' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType31_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCplType31_patterns_, ))
    validate_xCplType31_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xBairroType32(self, value):
        # Validate type xBairroType32, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xBairroType32' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xBairroType32' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType32_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xBairroType32_patterns_, ))
    validate_xBairroType32_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_xMunType33(self, value):
        # Validate type xMunType33, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType33' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType33' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType33_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType33_patterns_, ))
    validate_xMunType33_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_CEPType34(self, value):
        # Validate type CEPType34, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType34_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CEPType34_patterns_, ))
    validate_CEPType34_patterns_ = [['^[0-9]{8}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEnderFer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEnderFer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEnderFer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEnderFer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEnderFer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEnderFer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xLgr>%s</xLgr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nro>%s</nro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xCpl>%s</xCpl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xBairro>%s</xBairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMun>%s</cMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMun>%s</xMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CEP>%s</CEP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType29
            self.validate_xLgrType29(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType30
            self.validate_nroType30(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType31
            self.validate_xCplType31(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType32
            self.validate_xBairroType32(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType33
            self.validate_xMunType33(self.xMun)
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
            # validate type CEPType34
            self.validate_CEPType34(self.CEP)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
# end class TEnderFer


class TEndOrg(GeneratedsSuper):
    """Tipo Dados do Endereço"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, cPais=None, xPais=None, fone=None):
        self.original_tagname_ = None
        self.xLgr = xLgr
        self.validate_xLgrType35(self.xLgr)
        self.nro = nro
        self.validate_nroType36(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType37(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType38(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType39(self.xMun)
        self.CEP = CEP
        self.validate_CEPType40(self.CEP)
        self.UF = UF
        self.validate_TUf(self.UF)
        self.cPais = cPais
        self.validate_cPaisType41(self.cPais)
        self.xPais = xPais
        self.validate_xPaisType42(self.xPais)
        self.fone = fone
        self.validate_foneType43(self.fone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndOrg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndOrg.subclass:
            return TEndOrg.subclass(*args_, **kwargs_)
        else:
            return TEndOrg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_CEP(self): return self.CEP
    def set_CEP(self, CEP): self.CEP = CEP
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def get_cPais(self): return self.cPais
    def set_cPais(self, cPais): self.cPais = cPais
    def get_xPais(self): return self.xPais
    def set_xPais(self, xPais): self.xPais = xPais
    def get_fone(self): return self.fone
    def set_fone(self, fone): self.fone = fone
    def validate_xLgrType35(self, value):
        # Validate type xLgrType35, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLgrType35' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLgrType35' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType35_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLgrType35_patterns_, ))
    validate_xLgrType35_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nroType36(self, value):
        # Validate type nroType36, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nroType36' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nroType36' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType36_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nroType36_patterns_, ))
    validate_nroType36_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xCplType37(self, value):
        # Validate type xCplType37, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCplType37' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCplType37' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType37_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCplType37_patterns_, ))
    validate_xCplType37_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xBairroType38(self, value):
        # Validate type xBairroType38, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xBairroType38' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xBairroType38' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType38_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xBairroType38_patterns_, ))
    validate_xBairroType38_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_xMunType39(self, value):
        # Validate type xMunType39, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType39' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType39' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType39_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType39_patterns_, ))
    validate_xMunType39_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_CEPType40(self, value):
        # Validate type CEPType40, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType40_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CEPType40_patterns_, ))
    validate_CEPType40_patterns_ = [['^[0-9]{8}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def validate_cPaisType41(self, value):
        # Validate type cPaisType41, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType41_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cPaisType41_patterns_, ))
    validate_cPaisType41_patterns_ = [['^[0-9]{1,4}$']]
    def validate_xPaisType42(self, value):
        # Validate type xPaisType42, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xPaisType42' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xPaisType42' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xPaisType42_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xPaisType42_patterns_, ))
    validate_xPaisType42_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_foneType43(self, value):
        # Validate type foneType43, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType43_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_foneType43_patterns_, ))
    validate_foneType43_patterns_ = [['^[0-9]{7,10}$']]
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None or
            self.cPais is not None or
            self.xPais is not None or
            self.fone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndOrg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndOrg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndOrg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndOrg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndOrg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndOrg', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xLgr>%s</xLgr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nro>%s</nro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xCpl>%s</xCpl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xBairro>%s</xBairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMun>%s</cMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMun>%s</xMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CEP>%s</CEP>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cPais>%s</cPais>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), eol_))
        if self.xPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xPais>%s</xPais>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xPais), input_name='xPais')), eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fone>%s</fone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType35
            self.validate_xLgrType35(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType36
            self.validate_nroType36(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType37
            self.validate_xCplType37(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType38
            self.validate_xBairroType38(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType39
            self.validate_xMunType39(self.xMun)
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
            # validate type CEPType40
            self.validate_CEPType40(self.CEP)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
            # validate type cPaisType41
            self.validate_cPaisType41(self.cPais)
        elif nodeName_ == 'xPais':
            xPais_ = child_.text
            xPais_ = self.gds_validate_string(xPais_, node, 'xPais')
            self.xPais = xPais_
            # validate type xPaisType42
            self.validate_xPaisType42(self.xPais)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType43
            self.validate_foneType43(self.fone)
# end class TEndOrg


class TLocal(GeneratedsSuper):
    """Tipo Dados do Local de Origem ou Destino"""
    subclass = None
    superclass = None
    def __init__(self, cMun=None, xMun=None, UF=None):
        self.original_tagname_ = None
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType44(self.xMun)
        self.UF = UF
        self.validate_TUf(self.UF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TLocal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TLocal.subclass:
            return TLocal.subclass(*args_, **kwargs_)
        else:
            return TLocal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_xMunType44(self, value):
        # Validate type xMunType44, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType44' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType44' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType44_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType44_patterns_, ))
    validate_xMunType44_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TLocal', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TLocal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TLocal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TLocal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TLocal'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TLocal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMun>%s</cMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMun>%s</xMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType44
            self.validate_xMunType44(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
# end class TLocal


class TEndReEnt(GeneratedsSuper):
    """Tipo Dados do Local de Retirada ou Entrega"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, xNome=None, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, UF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.xNome = xNome
        self.validate_xNomeType45(self.xNome)
        self.xLgr = xLgr
        self.validate_xLgrType46(self.xLgr)
        self.nro = nro
        self.validate_nroType47(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType48(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType49(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType50(self.xMun)
        self.UF = UF
        self.validate_TUf(self.UF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndReEnt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndReEnt.subclass:
            return TEndReEnt.subclass(*args_, **kwargs_)
        else:
            return TEndReEnt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_xLgr(self): return self.xLgr
    def set_xLgr(self, xLgr): self.xLgr = xLgr
    def get_nro(self): return self.nro
    def set_nro(self, nro): self.nro = nro
    def get_xCpl(self): return self.xCpl
    def set_xCpl(self, xCpl): self.xCpl = xCpl
    def get_xBairro(self): return self.xBairro
    def set_xBairro(self, xBairro): self.xBairro = xBairro
    def get_cMun(self): return self.cMun
    def set_cMun(self, cMun): self.cMun = cMun
    def get_xMun(self): return self.xMun
    def set_xMun(self, xMun): self.xMun = xMun
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]
    def validate_xNomeType45(self, value):
        # Validate type xNomeType45, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeType45' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeType45' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType45_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeType45_patterns_, ))
    validate_xNomeType45_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xLgrType46(self, value):
        # Validate type xLgrType46, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLgrType46' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLgrType46' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType46_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLgrType46_patterns_, ))
    validate_xLgrType46_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nroType47(self, value):
        # Validate type nroType47, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nroType47' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nroType47' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType47_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nroType47_patterns_, ))
    validate_nroType47_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xCplType48(self, value):
        # Validate type xCplType48, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCplType48' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCplType48' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType48_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCplType48_patterns_, ))
    validate_xCplType48_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xBairroType49(self, value):
        # Validate type xBairroType49, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xBairroType49' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xBairroType49' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType49_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xBairroType49_patterns_, ))
    validate_xBairroType49_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_xMunType50(self, value):
        # Validate type xMunType50, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType50' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType50' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType50_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType50_patterns_, ))
    validate_xMunType50_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TEndReEnt', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndReEnt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TEndReEnt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TEndReEnt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TEndReEnt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TEndReEnt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPF>%s</CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xNome>%s</xNome>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), eol_))
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xLgr>%s</xLgr>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nro>%s</nro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xCpl>%s</xCpl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xBairro>%s</xBairro>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMun>%s</cMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMun>%s</xMun>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType45
            self.validate_xNomeType45(self.xNome)
        elif nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType46
            self.validate_xLgrType46(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType47
            self.validate_nroType47(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType48
            self.validate_xCplType48(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType49
            self.validate_xBairroType49(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType50
            self.validate_xMunType50(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
# end class TEndReEnt


class TNFeNF(GeneratedsSuper):
    """Tipo  de Dados das Notas Fiscais Papel e Eletrônica"""
    subclass = None
    superclass = None
    def __init__(self, infNFe=None, infNF=None):
        self.original_tagname_ = None
        self.infNFe = infNFe
        self.infNF = infNF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TNFeNF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TNFeNF.subclass:
            return TNFeNF.subclass(*args_, **kwargs_)
        else:
            return TNFeNF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infNFe(self): return self.infNFe
    def set_infNFe(self, infNFe): self.infNFe = infNFe
    def get_infNF(self): return self.infNF
    def set_infNF(self, infNF): self.infNF = infNF
    def hasContent_(self):
        if (
            self.infNFe is not None or
            self.infNF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TNFeNF', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TNFeNF')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TNFeNF')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TNFeNF', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TNFeNF'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TNFeNF', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infNFe is not None:
            self.infNFe.export(outfile, level, namespace_, name_='infNFe', pretty_print=pretty_print)
        if self.infNF is not None:
            self.infNF.export(outfile, level, namespace_, name_='infNF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infNFe':
            obj_ = infNFeType51.factory()
            obj_.build(child_)
            self.infNFe = obj_
            obj_.original_tagname_ = 'infNFe'
        elif nodeName_ == 'infNF':
            obj_ = infNFType.factory()
            obj_.build(child_)
            self.infNF = obj_
            obj_.original_tagname_ = 'infNF'
# end class TNFeNF


class TUnidadeTransp(GeneratedsSuper):
    """Tipo Dados Unidade de Transporte"""
    subclass = None
    superclass = None
    def __init__(self, tpUnidTransp=None, idUnidTransp=None, lacUnidTransp=None, infUnidCarga=None, qtdRat=None):
        self.original_tagname_ = None
        self.tpUnidTransp = tpUnidTransp
        self.validate_TtipoUnidTransp(self.tpUnidTransp)
        self.idUnidTransp = idUnidTransp
        self.validate_TContainer(self.idUnidTransp)
        if lacUnidTransp is None:
            self.lacUnidTransp = []
        else:
            self.lacUnidTransp = lacUnidTransp
        if infUnidCarga is None:
            self.infUnidCarga = []
        else:
            self.infUnidCarga = infUnidCarga
        self.qtdRat = qtdRat
        self.validate_TDec_0302_0303(self.qtdRat)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TUnidadeTransp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TUnidadeTransp.subclass:
            return TUnidadeTransp.subclass(*args_, **kwargs_)
        else:
            return TUnidadeTransp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpUnidTransp(self): return self.tpUnidTransp
    def set_tpUnidTransp(self, tpUnidTransp): self.tpUnidTransp = tpUnidTransp
    def get_idUnidTransp(self): return self.idUnidTransp
    def set_idUnidTransp(self, idUnidTransp): self.idUnidTransp = idUnidTransp
    def get_lacUnidTransp(self): return self.lacUnidTransp
    def set_lacUnidTransp(self, lacUnidTransp): self.lacUnidTransp = lacUnidTransp
    def add_lacUnidTransp(self, value): self.lacUnidTransp.append(value)
    def insert_lacUnidTransp_at(self, index, value): self.lacUnidTransp.insert(index, value)
    def replace_lacUnidTransp_at(self, index, value): self.lacUnidTransp[index] = value
    def get_infUnidCarga(self): return self.infUnidCarga
    def set_infUnidCarga(self, infUnidCarga): self.infUnidCarga = infUnidCarga
    def add_infUnidCarga(self, value): self.infUnidCarga.append(value)
    def insert_infUnidCarga_at(self, index, value): self.infUnidCarga.insert(index, value)
    def replace_infUnidCarga_at(self, index, value): self.infUnidCarga[index] = value
    def get_qtdRat(self): return self.qtdRat
    def set_qtdRat(self, qtdRat): self.qtdRat = qtdRat
    def validate_TtipoUnidTransp(self, value):
        # Validate type TtipoUnidTransp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TtipoUnidTransp' % {"value" : value.encode("utf-8")} )
    def validate_TContainer(self, value):
        # Validate type TContainer, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TContainer' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TContainer' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TContainer_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TContainer_patterns_, ))
    validate_TContainer_patterns_ = [['^[A-Z0-9]+$']]
    def validate_TDec_0302_0303(self, value):
        # Validate type TDec_0302_0303, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_0303_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302_0303_patterns_, ))
    validate_TDec_0302_0303_patterns_ = [['^[0-9]{1,3}(\\.[0-9]{2,3})?$']]
    def hasContent_(self):
        if (
            self.tpUnidTransp is not None or
            self.idUnidTransp is not None or
            self.lacUnidTransp or
            self.infUnidCarga or
            self.qtdRat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TUnidadeTransp', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TUnidadeTransp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TUnidadeTransp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TUnidadeTransp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TUnidadeTransp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TUnidadeTransp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpUnidTransp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpUnidTransp>%s</tpUnidTransp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpUnidTransp), input_name='tpUnidTransp')), eol_))
        if self.idUnidTransp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<idUnidTransp>%s</idUnidTransp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.idUnidTransp), input_name='idUnidTransp')), eol_))
        for lacUnidTransp_ in self.lacUnidTransp:
            lacUnidTransp_.export(outfile, level, namespace_, name_='lacUnidTransp', pretty_print=pretty_print)
        for infUnidCarga_ in self.infUnidCarga:
            infUnidCarga_.export(outfile, level, namespace_, name_='infUnidCarga', pretty_print=pretty_print)
        if self.qtdRat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qtdRat>%s</qtdRat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qtdRat), input_name='qtdRat')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpUnidTransp':
            tpUnidTransp_ = child_.text
            tpUnidTransp_ = self.gds_validate_string(tpUnidTransp_, node, 'tpUnidTransp')
            self.tpUnidTransp = tpUnidTransp_
            # validate type TtipoUnidTransp
            self.validate_TtipoUnidTransp(self.tpUnidTransp)
        elif nodeName_ == 'idUnidTransp':
            idUnidTransp_ = child_.text
            idUnidTransp_ = self.gds_validate_string(idUnidTransp_, node, 'idUnidTransp')
            self.idUnidTransp = idUnidTransp_
            # validate type TContainer
            self.validate_TContainer(self.idUnidTransp)
        elif nodeName_ == 'lacUnidTransp':
            obj_ = lacUnidTranspType.factory()
            obj_.build(child_)
            self.lacUnidTransp.append(obj_)
            obj_.original_tagname_ = 'lacUnidTransp'
        elif nodeName_ == 'infUnidCarga':
            obj_ = TUnidCarga.factory()
            obj_.build(child_)
            self.infUnidCarga.append(obj_)
            obj_.original_tagname_ = 'infUnidCarga'
        elif nodeName_ == 'qtdRat':
            qtdRat_ = child_.text
            qtdRat_ = self.gds_validate_string(qtdRat_, node, 'qtdRat')
            self.qtdRat = qtdRat_
            # validate type TDec_0302_0303
            self.validate_TDec_0302_0303(self.qtdRat)
# end class TUnidadeTransp


class TUnidCarga(GeneratedsSuper):
    """Tipo Dados Unidade de Carga"""
    subclass = None
    superclass = None
    def __init__(self, tpUnidCarga=None, idUnidCarga=None, lacUnidCarga=None, qtdRat=None):
        self.original_tagname_ = None
        self.tpUnidCarga = tpUnidCarga
        self.validate_TtipoUnidCarga(self.tpUnidCarga)
        self.idUnidCarga = idUnidCarga
        self.validate_TContainer(self.idUnidCarga)
        if lacUnidCarga is None:
            self.lacUnidCarga = []
        else:
            self.lacUnidCarga = lacUnidCarga
        self.qtdRat = qtdRat
        self.validate_qtdRatType(self.qtdRat)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TUnidCarga)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TUnidCarga.subclass:
            return TUnidCarga.subclass(*args_, **kwargs_)
        else:
            return TUnidCarga(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpUnidCarga(self): return self.tpUnidCarga
    def set_tpUnidCarga(self, tpUnidCarga): self.tpUnidCarga = tpUnidCarga
    def get_idUnidCarga(self): return self.idUnidCarga
    def set_idUnidCarga(self, idUnidCarga): self.idUnidCarga = idUnidCarga
    def get_lacUnidCarga(self): return self.lacUnidCarga
    def set_lacUnidCarga(self, lacUnidCarga): self.lacUnidCarga = lacUnidCarga
    def add_lacUnidCarga(self, value): self.lacUnidCarga.append(value)
    def insert_lacUnidCarga_at(self, index, value): self.lacUnidCarga.insert(index, value)
    def replace_lacUnidCarga_at(self, index, value): self.lacUnidCarga[index] = value
    def get_qtdRat(self): return self.qtdRat
    def set_qtdRat(self, qtdRat): self.qtdRat = qtdRat
    def validate_TtipoUnidCarga(self, value):
        # Validate type TtipoUnidCarga, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TtipoUnidCarga' % {"value" : value.encode("utf-8")} )
    def validate_TContainer(self, value):
        # Validate type TContainer, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TContainer' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TContainer' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TContainer_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TContainer_patterns_, ))
    validate_TContainer_patterns_ = [['^[A-Z0-9]+$']]
    def validate_qtdRatType(self, value):
        # Validate type qtdRatType, a restriction on TDec_0302_0303.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_qtdRatType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qtdRatType_patterns_, ))
    validate_qtdRatType_patterns_ = [['^[0-9]{1,3}(\\.[0-9]{2,3})?$']]
    def hasContent_(self):
        if (
            self.tpUnidCarga is not None or
            self.idUnidCarga is not None or
            self.lacUnidCarga or
            self.qtdRat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TUnidCarga', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TUnidCarga')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TUnidCarga')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TUnidCarga', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TUnidCarga'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TUnidCarga', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpUnidCarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpUnidCarga>%s</tpUnidCarga>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpUnidCarga), input_name='tpUnidCarga')), eol_))
        if self.idUnidCarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<idUnidCarga>%s</idUnidCarga>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.idUnidCarga), input_name='idUnidCarga')), eol_))
        for lacUnidCarga_ in self.lacUnidCarga:
            lacUnidCarga_.export(outfile, level, namespace_, name_='lacUnidCarga', pretty_print=pretty_print)
        if self.qtdRat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qtdRat>%s</qtdRat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qtdRat), input_name='qtdRat')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpUnidCarga':
            tpUnidCarga_ = child_.text
            tpUnidCarga_ = self.gds_validate_string(tpUnidCarga_, node, 'tpUnidCarga')
            self.tpUnidCarga = tpUnidCarga_
            # validate type TtipoUnidCarga
            self.validate_TtipoUnidCarga(self.tpUnidCarga)
        elif nodeName_ == 'idUnidCarga':
            idUnidCarga_ = child_.text
            idUnidCarga_ = self.gds_validate_string(idUnidCarga_, node, 'idUnidCarga')
            self.idUnidCarga = idUnidCarga_
            # validate type TContainer
            self.validate_TContainer(self.idUnidCarga)
        elif nodeName_ == 'lacUnidCarga':
            obj_ = lacUnidCargaType.factory()
            obj_.build(child_)
            self.lacUnidCarga.append(obj_)
            obj_.original_tagname_ = 'lacUnidCarga'
        elif nodeName_ == 'qtdRat':
            qtdRat_ = child_.text
            qtdRat_ = self.gds_validate_string(qtdRat_, node, 'qtdRat')
            self.qtdRat = qtdRat_
            # validate type qtdRatType
            self.validate_qtdRatType(self.qtdRat)
# end class TUnidCarga


class SignatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignedInfo=None, SignatureValue=None, KeyInfo=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.SignedInfo = SignedInfo
        self.SignatureValue = SignatureValue
        self.KeyInfo = KeyInfo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureType.subclass:
            return SignatureType.subclass(*args_, **kwargs_)
        else:
            return SignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SignedInfo(self): return self.SignedInfo
    def set_SignedInfo(self, SignedInfo): self.SignedInfo = SignedInfo
    def get_SignatureValue(self): return self.SignatureValue
    def set_SignatureValue(self, SignatureValue): self.SignatureValue = SignatureValue
    def get_KeyInfo(self): return self.KeyInfo
    def set_KeyInfo(self, KeyInfo): self.KeyInfo = KeyInfo
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.SignedInfo is not None or
            self.SignatureValue is not None or
            self.KeyInfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignatureType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignatureType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SignedInfo is not None:
            self.SignedInfo.export(outfile, level, namespace_, name_='SignedInfo', pretty_print=pretty_print)
        if self.SignatureValue is not None:
            self.SignatureValue.export(outfile, level, namespace_, name_='SignatureValue', pretty_print=pretty_print)
        if self.KeyInfo is not None:
            self.KeyInfo.export(outfile, level, namespace_, name_='KeyInfo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SignedInfo':
            obj_ = SignedInfoType.factory()
            obj_.build(child_)
            self.SignedInfo = obj_
            obj_.original_tagname_ = 'SignedInfo'
        elif nodeName_ == 'SignatureValue':
            obj_ = SignatureValueType.factory()
            obj_.build(child_)
            self.SignatureValue = obj_
            obj_.original_tagname_ = 'SignatureValue'
        elif nodeName_ == 'KeyInfo':
            obj_ = KeyInfoType.factory()
            obj_.build(child_)
            self.KeyInfo = obj_
            obj_.original_tagname_ = 'KeyInfo'
# end class SignatureType


class SignatureValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, valueOf_=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureValueType.subclass:
            return SignatureValueType.subclass(*args_, **kwargs_)
        else:
            return SignatureValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignatureValueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignatureValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignatureValueType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignatureValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureValueType


class SignedInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, CanonicalizationMethod=None, SignatureMethod=None, Reference=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.CanonicalizationMethod = CanonicalizationMethod
        self.SignatureMethod = SignatureMethod
        self.Reference = Reference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedInfoType.subclass:
            return SignedInfoType.subclass(*args_, **kwargs_)
        else:
            return SignedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CanonicalizationMethod(self): return self.CanonicalizationMethod
    def set_CanonicalizationMethod(self, CanonicalizationMethod): self.CanonicalizationMethod = CanonicalizationMethod
    def get_SignatureMethod(self): return self.SignatureMethod
    def set_SignatureMethod(self, SignatureMethod): self.SignatureMethod = SignatureMethod
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.CanonicalizationMethod is not None or
            self.SignatureMethod is not None or
            self.Reference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignedInfoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignedInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignedInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignedInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignedInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignedInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CanonicalizationMethod is not None:
            self.CanonicalizationMethod.export(outfile, level, namespace_, name_='CanonicalizationMethod', pretty_print=pretty_print)
        if self.SignatureMethod is not None:
            self.SignatureMethod.export(outfile, level, namespace_, name_='SignatureMethod', pretty_print=pretty_print)
        if self.Reference is not None:
            self.Reference.export(outfile, level, namespace_, name_='Reference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CanonicalizationMethod':
            obj_ = CanonicalizationMethodType.factory()
            obj_.build(child_)
            self.CanonicalizationMethod = obj_
            obj_.original_tagname_ = 'CanonicalizationMethod'
        elif nodeName_ == 'SignatureMethod':
            obj_ = SignatureMethodType.factory()
            obj_.build(child_)
            self.SignatureMethod = obj_
            obj_.original_tagname_ = 'SignatureMethod'
        elif nodeName_ == 'Reference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference = obj_
            obj_.original_tagname_ = 'Reference'
# end class SignedInfoType


class ReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, URI=None, Type=None, Transforms=None, DigestMethod=None, DigestValue=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.URI = _cast(None, URI)
        self.Type = _cast(None, Type)
        self.Transforms = Transforms
        self.DigestMethod = DigestMethod
        self.DigestValue = DigestValue
        self.validate_DigestValueType(self.DigestValue)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transforms(self): return self.Transforms
    def set_Transforms(self, Transforms): self.Transforms = Transforms
    def get_DigestMethod(self): return self.DigestMethod
    def set_DigestMethod(self, DigestMethod): self.DigestMethod = DigestMethod
    def get_DigestValue(self): return self.DigestValue
    def set_DigestValue(self, DigestValue): self.DigestValue = DigestValue
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_URI(self): return self.URI
    def set_URI(self, URI): self.URI = URI
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_DigestValueType(self, value):
        # Validate type DigestValueType, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Transforms is not None or
            self.DigestMethod is not None or
            self.DigestValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            self.Transforms.export(outfile, level, namespace_, name_='Transforms', pretty_print=pretty_print)
        if self.DigestMethod is not None:
            self.DigestMethod.export(outfile, level, namespace_, name_='DigestMethod', pretty_print=pretty_print)
        if self.DigestValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DigestValue>%s</DigestValue>%s' % (self.gds_format_base64(self.DigestValue, input_name='DigestValue'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory()
            obj_.build(child_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
        elif nodeName_ == 'DigestMethod':
            obj_ = DigestMethodType.factory()
            obj_.build(child_)
            self.DigestMethod = obj_
            obj_.original_tagname_ = 'DigestMethod'
        elif nodeName_ == 'DigestValue':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'DigestValue')
            else:
                bval_ = None
            self.DigestValue = bval_
            # validate type DigestValueType
            self.validate_DigestValueType(self.DigestValue)
# end class ReferenceType


class TransformsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Transform=None):
        self.original_tagname_ = None
        if Transform is None:
            self.Transform = []
        else:
            self.Transform = Transform
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformsType.subclass:
            return TransformsType.subclass(*args_, **kwargs_)
        else:
            return TransformsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transform(self): return self.Transform
    def set_Transform(self, Transform): self.Transform = Transform
    def add_Transform(self, value): self.Transform.append(value)
    def insert_Transform_at(self, index, value): self.Transform.insert(index, value)
    def replace_Transform_at(self, index, value): self.Transform[index] = value
    def hasContent_(self):
        if (
            self.Transform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TransformsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransformsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TransformsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransformsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TransformsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transform_ in self.Transform:
            Transform_.export(outfile, level, namespace_, name_='Transform', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transform':
            obj_ = TransformType.factory()
            obj_.build(child_)
            self.Transform.append(obj_)
            obj_.original_tagname_ = 'Transform'
# end class TransformsType


class TransformType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, XPath=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
        if XPath is None:
            self.XPath = []
        else:
            self.XPath = XPath
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformType.subclass:
            return TransformType.subclass(*args_, **kwargs_)
        else:
            return TransformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_XPath(self): return self.XPath
    def set_XPath(self, XPath): self.XPath = XPath
    def add_XPath(self, value): self.XPath.append(value)
    def insert_XPath_at(self, index, value): self.XPath.insert(index, value)
    def replace_XPath_at(self, index, value): self.XPath[index] = value
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def hasContent_(self):
        if (
            self.XPath
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TransformType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TransformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TransformType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TransformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for XPath_ in self.XPath:
            showIndent(outfile, level, pretty_print)
            outfile.write('<XPath>%s</XPath>%s' % (self.gds_encode(self.gds_format_string(quote_xml(XPath_), input_name='XPath')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'XPath':
            XPath_ = child_.text
            XPath_ = self.gds_validate_string(XPath_, node, 'XPath')
            self.XPath.append(XPath_)
# end class TransformType


class KeyInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, X509Data=None):
        self.original_tagname_ = None
        self.Id = _cast(None, Id)
        self.X509Data = X509Data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyInfoType.subclass:
            return KeyInfoType.subclass(*args_, **kwargs_)
        else:
            return KeyInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X509Data(self): return self.X509Data
    def set_X509Data(self, X509Data): self.X509Data = X509Data
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.X509Data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KeyInfoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeyInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KeyInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeyInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='KeyInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Data is not None:
            self.X509Data.export(outfile, level, namespace_, name_='X509Data', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509Data':
            obj_ = X509DataType.factory()
            obj_.build(child_)
            self.X509Data = obj_
            obj_.original_tagname_ = 'X509Data'
# end class KeyInfoType


class X509DataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X509Certificate=None):
        self.original_tagname_ = None
        self.X509Certificate = X509Certificate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509DataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509DataType.subclass:
            return X509DataType.subclass(*args_, **kwargs_)
        else:
            return X509DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X509Certificate(self): return self.X509Certificate
    def set_X509Certificate(self, X509Certificate): self.X509Certificate = X509Certificate
    def hasContent_(self):
        if (
            self.X509Certificate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='X509DataType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509DataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='X509DataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='X509DataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='X509DataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='X509DataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Certificate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<X509Certificate>%s</X509Certificate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.X509Certificate), input_name='X509Certificate')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509Certificate':
            X509Certificate_ = child_.text
            X509Certificate_ = self.gds_validate_string(X509Certificate_, node, 'X509Certificate')
            self.X509Certificate = X509Certificate_
# end class X509DataType


class infMDFeType(GeneratedsSuper):
    """Informações do MDF-e"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, Id=None, ide=None, emit=None, infModal=None, infDoc=None, seg=None, tot=None, lacres=None, autXML=None, infAdic=None):
        self.original_tagname_ = None
        self.versao = _cast(None, versao)
        self.Id = _cast(None, Id)
        self.ide = ide
        self.emit = emit
        self.infModal = infModal
        self.infDoc = infDoc
        if seg is None:
            self.seg = []
        else:
            self.seg = seg
        self.tot = tot
        if lacres is None:
            self.lacres = []
        else:
            self.lacres = lacres
        if autXML is None:
            self.autXML = []
        else:
            self.autXML = autXML
        self.infAdic = infAdic
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infMDFeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infMDFeType.subclass:
            return infMDFeType.subclass(*args_, **kwargs_)
        else:
            return infMDFeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ide(self): return self.ide
    def set_ide(self, ide): self.ide = ide
    def get_emit(self): return self.emit
    def set_emit(self, emit): self.emit = emit
    def get_infModal(self): return self.infModal
    def set_infModal(self, infModal): self.infModal = infModal
    def get_infDoc(self): return self.infDoc
    def set_infDoc(self, infDoc): self.infDoc = infDoc
    def get_seg(self): return self.seg
    def set_seg(self, seg): self.seg = seg
    def add_seg(self, value): self.seg.append(value)
    def insert_seg_at(self, index, value): self.seg.insert(index, value)
    def replace_seg_at(self, index, value): self.seg[index] = value
    def get_tot(self): return self.tot
    def set_tot(self, tot): self.tot = tot
    def get_lacres(self): return self.lacres
    def set_lacres(self, lacres): self.lacres = lacres
    def add_lacres(self, value): self.lacres.append(value)
    def insert_lacres_at(self, index, value): self.lacres.insert(index, value)
    def replace_lacres_at(self, index, value): self.lacres[index] = value
    def get_autXML(self): return self.autXML
    def set_autXML(self, autXML): self.autXML = autXML
    def add_autXML(self, value): self.autXML.append(value)
    def insert_autXML_at(self, index, value): self.autXML.insert(index, value)
    def replace_autXML_at(self, index, value): self.autXML[index] = value
    def get_infAdic(self): return self.infAdic
    def set_infAdic(self, infAdic): self.infAdic = infAdic
    def get_versao(self): return self.versao
    def set_versao(self, versao): self.versao = versao
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def validate_TVerMDe(self, value):
        # Validate type TVerMDe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerMDe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerMDe_patterns_, ))
    validate_TVerMDe_patterns_ = [['^3\\.00$']]
    def hasContent_(self):
        if (
            self.ide is not None or
            self.emit is not None or
            self.infModal is not None or
            self.infDoc is not None or
            self.seg or
            self.tot is not None or
            self.lacres or
            self.autXML or
            self.infAdic is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infMDFeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infMDFeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infMDFeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infMDFeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infMDFeType'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='infMDFeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ide is not None:
            self.ide.export(outfile, level, namespace_, name_='ide', pretty_print=pretty_print)
        if self.emit is not None:
            self.emit.export(outfile, level, namespace_, name_='emit', pretty_print=pretty_print)
        if self.infModal is not None:
            self.infModal.export(outfile, level, namespace_, name_='infModal', pretty_print=pretty_print)
        if self.infDoc is not None:
            self.infDoc.export(outfile, level, namespace_, name_='infDoc', pretty_print=pretty_print)
        for seg_ in self.seg:
            seg_.export(outfile, level, namespace_, name_='seg', pretty_print=pretty_print)
        if self.tot is not None:
            self.tot.export(outfile, level, namespace_, name_='tot', pretty_print=pretty_print)
        for lacres_ in self.lacres:
            lacres_.export(outfile, level, namespace_, name_='lacres', pretty_print=pretty_print)
        for autXML_ in self.autXML:
            autXML_.export(outfile, level, namespace_, name_='autXML', pretty_print=pretty_print)
        if self.infAdic is not None:
            self.infAdic.export(outfile, level, namespace_, name_='infAdic', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerMDe(self.versao)    # validate type TVerMDe
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ide':
            obj_ = ideType.factory()
            obj_.build(child_)
            self.ide = obj_
            obj_.original_tagname_ = 'ide'
        elif nodeName_ == 'emit':
            obj_ = emitType.factory()
            obj_.build(child_)
            self.emit = obj_
            obj_.original_tagname_ = 'emit'
        elif nodeName_ == 'infModal':
            obj_ = infModalType.factory()
            obj_.build(child_)
            self.infModal = obj_
            obj_.original_tagname_ = 'infModal'
        elif nodeName_ == 'infDoc':
            obj_ = infDocType.factory()
            obj_.build(child_)
            self.infDoc = obj_
            obj_.original_tagname_ = 'infDoc'
        elif nodeName_ == 'seg':
            obj_ = segType.factory()
            obj_.build(child_)
            self.seg.append(obj_)
            obj_.original_tagname_ = 'seg'
        elif nodeName_ == 'tot':
            obj_ = totType.factory()
            obj_.build(child_)
            self.tot = obj_
            obj_.original_tagname_ = 'tot'
        elif nodeName_ == 'lacres':
            obj_ = lacresType.factory()
            obj_.build(child_)
            self.lacres.append(obj_)
            obj_.original_tagname_ = 'lacres'
        elif nodeName_ == 'autXML':
            obj_ = autXMLType.factory()
            obj_.build(child_)
            self.autXML.append(obj_)
            obj_.original_tagname_ = 'autXML'
        elif nodeName_ == 'infAdic':
            obj_ = infAdicType.factory()
            obj_.build(child_)
            self.infAdic = obj_
            obj_.original_tagname_ = 'infAdic'
# end class infMDFeType


class ideType(GeneratedsSuper):
    """Identificação do MDF-e"""
    subclass = None
    superclass = None
    def __init__(self, cUF=None, tpAmb=None, tpEmit=None, tpTransp=None, mod=None, serie=None, nMDF=None, cMDF=None, cDV=None, modal=None, dhEmi=None, tpEmis=None, procEmi=None, verProc=None, UFIni=None, UFFim=None, infMunCarrega=None, infPercurso=None, dhIniViagem=None, indCanalVerde=None):
        self.original_tagname_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.tpEmit = tpEmit
        self.validate_TEmit(self.tpEmit)
        self.tpTransp = tpTransp
        self.validate_TTransp(self.tpTransp)
        self.mod = mod
        self.validate_TModMD(self.mod)
        self.serie = serie
        self.validate_TSerie(self.serie)
        self.nMDF = nMDF
        self.validate_TNF(self.nMDF)
        self.cMDF = cMDF
        self.validate_cMDFType(self.cMDF)
        self.cDV = cDV
        self.validate_cDVType(self.cDV)
        self.modal = modal
        self.validate_TModalMD(self.modal)
        self.dhEmi = dhEmi
        self.validate_TDateTimeUTC(self.dhEmi)
        self.tpEmis = tpEmis
        self.validate_tpEmisType(self.tpEmis)
        self.procEmi = procEmi
        self.validate_procEmiType(self.procEmi)
        self.verProc = verProc
        self.validate_verProcType(self.verProc)
        self.UFIni = UFIni
        self.validate_TUf(self.UFIni)
        self.UFFim = UFFim
        self.validate_TUf(self.UFFim)
        if infMunCarrega is None:
            self.infMunCarrega = []
        else:
            self.infMunCarrega = infMunCarrega
        if infPercurso is None:
            self.infPercurso = []
        else:
            self.infPercurso = infPercurso
        self.dhIniViagem = dhIniViagem
        self.validate_TDateTimeUTC(self.dhIniViagem)
        self.indCanalVerde = indCanalVerde
        self.validate_indCanalVerdeType(self.indCanalVerde)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideType.subclass:
            return ideType.subclass(*args_, **kwargs_)
        else:
            return ideType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cUF(self): return self.cUF
    def set_cUF(self, cUF): self.cUF = cUF
    def get_tpAmb(self): return self.tpAmb
    def set_tpAmb(self, tpAmb): self.tpAmb = tpAmb
    def get_tpEmit(self): return self.tpEmit
    def set_tpEmit(self, tpEmit): self.tpEmit = tpEmit
    def get_tpTransp(self): return self.tpTransp
    def set_tpTransp(self, tpTransp): self.tpTransp = tpTransp
    def get_mod(self): return self.mod
    def set_mod(self, mod): self.mod = mod
    def get_serie(self): return self.serie
    def set_serie(self, serie): self.serie = serie
    def get_nMDF(self): return self.nMDF
    def set_nMDF(self, nMDF): self.nMDF = nMDF
    def get_cMDF(self): return self.cMDF
    def set_cMDF(self, cMDF): self.cMDF = cMDF
    def get_cDV(self): return self.cDV
    def set_cDV(self, cDV): self.cDV = cDV
    def get_modal(self): return self.modal
    def set_modal(self, modal): self.modal = modal
    def get_dhEmi(self): return self.dhEmi
    def set_dhEmi(self, dhEmi): self.dhEmi = dhEmi
    def get_tpEmis(self): return self.tpEmis
    def set_tpEmis(self, tpEmis): self.tpEmis = tpEmis
    def get_procEmi(self): return self.procEmi
    def set_procEmi(self, procEmi): self.procEmi = procEmi
    def get_verProc(self): return self.verProc
    def set_verProc(self, verProc): self.verProc = verProc
    def get_UFIni(self): return self.UFIni
    def set_UFIni(self, UFIni): self.UFIni = UFIni
    def get_UFFim(self): return self.UFFim
    def set_UFFim(self, UFFim): self.UFFim = UFFim
    def get_infMunCarrega(self): return self.infMunCarrega
    def set_infMunCarrega(self, infMunCarrega): self.infMunCarrega = infMunCarrega
    def add_infMunCarrega(self, value): self.infMunCarrega.append(value)
    def insert_infMunCarrega_at(self, index, value): self.infMunCarrega.insert(index, value)
    def replace_infMunCarrega_at(self, index, value): self.infMunCarrega[index] = value
    def get_infPercurso(self): return self.infPercurso
    def set_infPercurso(self, infPercurso): self.infPercurso = infPercurso
    def add_infPercurso(self, value): self.infPercurso.append(value)
    def insert_infPercurso_at(self, index, value): self.infPercurso.insert(index, value)
    def replace_infPercurso_at(self, index, value): self.infPercurso[index] = value
    def get_dhIniViagem(self): return self.dhIniViagem
    def set_dhIniViagem(self, dhIniViagem): self.dhIniViagem = dhIniViagem
    def get_indCanalVerde(self): return self.indCanalVerde
    def set_indCanalVerde(self, indCanalVerde): self.indCanalVerde = indCanalVerde
    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : value.encode("utf-8")} )
    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {"value" : value.encode("utf-8")} )
    def validate_TEmit(self, value):
        # Validate type TEmit, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TEmit' % {"value" : value.encode("utf-8")} )
    def validate_TTransp(self, value):
        # Validate type TTransp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TTransp' % {"value" : value.encode("utf-8")} )
    def validate_TModMD(self, value):
        # Validate type TModMD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['58']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TModMD' % {"value" : value.encode("utf-8")} )
    def validate_TSerie(self, value):
        # Validate type TSerie, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TSerie_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TSerie_patterns_, ))
    validate_TSerie_patterns_ = [['^0$|^[1-9]{1}[0-9]{0,2}$']]
    def validate_TNF(self, value):
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TNF_patterns_, ))
    validate_TNF_patterns_ = [['^[1-9]{1}[0-9]{0,8}$']]
    def validate_cMDFType(self, value):
        # Validate type cMDFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cMDFType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cMDFType_patterns_, ))
    validate_cMDFType_patterns_ = [['^[0-9]{8}$']]
    def validate_cDVType(self, value):
        # Validate type cDVType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cDVType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cDVType_patterns_, ))
    validate_cDVType_patterns_ = [['^[0-9]{1}$']]
    def validate_TModalMD(self, value):
        # Validate type TModalMD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TModalMD' % {"value" : value.encode("utf-8")} )
    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))T(20$|^21$|^22$|^23$|^[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]$|^10$|^11):00$|^([\\+](12):00))$']]
    def validate_tpEmisType(self, value):
        # Validate type tpEmisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpEmisType' % {"value" : value.encode("utf-8")} )
    def validate_procEmiType(self, value):
        # Validate type procEmiType, a restriction on TProcEmi.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on procEmiType' % {"value" : value.encode("utf-8")} )
    def validate_verProcType(self, value):
        # Validate type verProcType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on verProcType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on verProcType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_verProcType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_verProcType_patterns_, ))
    validate_verProcType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def validate_indCanalVerdeType(self, value):
        # Validate type indCanalVerdeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indCanalVerdeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cUF is not None or
            self.tpAmb is not None or
            self.tpEmit is not None or
            self.tpTransp is not None or
            self.mod is not None or
            self.serie is not None or
            self.nMDF is not None or
            self.cMDF is not None or
            self.cDV is not None or
            self.modal is not None or
            self.dhEmi is not None or
            self.tpEmis is not None or
            self.procEmi is not None or
            self.verProc is not None or
            self.UFIni is not None or
            self.UFFim is not None or
            self.infMunCarrega or
            self.infPercurso or
            self.dhIniViagem is not None or
            self.indCanalVerde is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ideType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ideType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ideType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ideType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ideType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cUF>%s</cUF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), eol_))
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpAmb>%s</tpAmb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), eol_))
        if self.tpEmit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpEmit>%s</tpEmit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpEmit), input_name='tpEmit')), eol_))
        if self.tpTransp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpTransp>%s</tpTransp>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpTransp), input_name='tpTransp')), eol_))
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<mod>%s</mod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), eol_))
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<serie>%s</serie>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), eol_))
        if self.nMDF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nMDF>%s</nMDF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nMDF), input_name='nMDF')), eol_))
        if self.cMDF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMDF>%s</cMDF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMDF), input_name='cMDF')), eol_))
        if self.cDV is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cDV>%s</cDV>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cDV), input_name='cDV')), eol_))
        if self.modal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<modal>%s</modal>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.modal), input_name='modal')), eol_))
        if self.dhEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dhEmi>%s</dhEmi>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dhEmi), input_name='dhEmi')), eol_))
        if self.tpEmis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tpEmis>%s</tpEmis>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tpEmis), input_name='tpEmis')), eol_))
        if self.procEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<procEmi>%s</procEmi>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.procEmi), input_name='procEmi')), eol_))
        if self.verProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<verProc>%s</verProc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.verProc), input_name='verProc')), eol_))
        if self.UFIni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UFIni>%s</UFIni>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UFIni), input_name='UFIni')), eol_))
        if self.UFFim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UFFim>%s</UFFim>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UFFim), input_name='UFFim')), eol_))
        for infMunCarrega_ in self.infMunCarrega:
            infMunCarrega_.export(outfile, level, namespace_, name_='infMunCarrega', pretty_print=pretty_print)
        for infPercurso_ in self.infPercurso:
            infPercurso_.export(outfile, level, namespace_, name_='infPercurso', pretty_print=pretty_print)
        if self.dhIniViagem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dhIniViagem>%s</dhIniViagem>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dhIniViagem), input_name='dhIniViagem')), eol_))
        if self.indCanalVerde is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indCanalVerde>%s</indCanalVerde>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indCanalVerde), input_name='indCanalVerde')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'tpEmit':
            tpEmit_ = child_.text
            tpEmit_ = self.gds_validate_string(tpEmit_, node, 'tpEmit')
            self.tpEmit = tpEmit_
            # validate type TEmit
            self.validate_TEmit(self.tpEmit)
        elif nodeName_ == 'tpTransp':
            tpTransp_ = child_.text
            tpTransp_ = self.gds_validate_string(tpTransp_, node, 'tpTransp')
            self.tpTransp = tpTransp_
            # validate type TTransp
            self.validate_TTransp(self.tpTransp)
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type TModMD
            self.validate_TModMD(self.mod)
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
            # validate type TSerie
            self.validate_TSerie(self.serie)
        elif nodeName_ == 'nMDF':
            nMDF_ = child_.text
            nMDF_ = self.gds_validate_string(nMDF_, node, 'nMDF')
            self.nMDF = nMDF_
            # validate type TNF
            self.validate_TNF(self.nMDF)
        elif nodeName_ == 'cMDF':
            cMDF_ = child_.text
            cMDF_ = self.gds_validate_string(cMDF_, node, 'cMDF')
            self.cMDF = cMDF_
            # validate type cMDFType
            self.validate_cMDFType(self.cMDF)
        elif nodeName_ == 'cDV':
            cDV_ = child_.text
            cDV_ = self.gds_validate_string(cDV_, node, 'cDV')
            self.cDV = cDV_
            # validate type cDVType
            self.validate_cDVType(self.cDV)
        elif nodeName_ == 'modal':
            modal_ = child_.text
            modal_ = self.gds_validate_string(modal_, node, 'modal')
            self.modal = modal_
            # validate type TModalMD
            self.validate_TModalMD(self.modal)
        elif nodeName_ == 'dhEmi':
            dhEmi_ = child_.text
            dhEmi_ = self.gds_validate_string(dhEmi_, node, 'dhEmi')
            self.dhEmi = dhEmi_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhEmi)
        elif nodeName_ == 'tpEmis':
            tpEmis_ = child_.text
            tpEmis_ = self.gds_validate_string(tpEmis_, node, 'tpEmis')
            self.tpEmis = tpEmis_
            # validate type tpEmisType
            self.validate_tpEmisType(self.tpEmis)
        elif nodeName_ == 'procEmi':
            procEmi_ = child_.text
            procEmi_ = self.gds_validate_string(procEmi_, node, 'procEmi')
            self.procEmi = procEmi_
            # validate type procEmiType
            self.validate_procEmiType(self.procEmi)
        elif nodeName_ == 'verProc':
            verProc_ = child_.text
            verProc_ = self.gds_validate_string(verProc_, node, 'verProc')
            self.verProc = verProc_
            # validate type verProcType
            self.validate_verProcType(self.verProc)
        elif nodeName_ == 'UFIni':
            UFIni_ = child_.text
            UFIni_ = self.gds_validate_string(UFIni_, node, 'UFIni')
            self.UFIni = UFIni_
            # validate type TUf
            self.validate_TUf(self.UFIni)
        elif nodeName_ == 'UFFim':
            UFFim_ = child_.text
            UFFim_ = self.gds_validate_string(UFFim_, node, 'UFFim')
            self.UFFim = UFFim_
            # validate type TUf
            self.validate_TUf(self.UFFim)
        elif nodeName_ == 'infMunCarrega':
            obj_ = infMunCarregaType.factory()
            obj_.build(child_)
            self.infMunCarrega.append(obj_)
            obj_.original_tagname_ = 'infMunCarrega'
        elif nodeName_ == 'infPercurso':
            obj_ = infPercursoType.factory()
            obj_.build(child_)
            self.infPercurso.append(obj_)
            obj_.original_tagname_ = 'infPercurso'
        elif nodeName_ == 'dhIniViagem':
            dhIniViagem_ = child_.text
            dhIniViagem_ = self.gds_validate_string(dhIniViagem_, node, 'dhIniViagem')
            self.dhIniViagem = dhIniViagem_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhIniViagem)
        elif nodeName_ == 'indCanalVerde':
            indCanalVerde_ = child_.text
            indCanalVerde_ = self.gds_validate_string(indCanalVerde_, node, 'indCanalVerde')
            self.indCanalVerde = indCanalVerde_
            # validate type indCanalVerdeType
            self.validate_indCanalVerdeType(self.indCanalVerde)
# end class ideType


class infMunCarregaType(GeneratedsSuper):
    """Informações dos Municípios de Carregamento"""
    subclass = None
    superclass = None
    def __init__(self, cMunCarrega=None, xMunCarrega=None):
        self.original_tagname_ = None
        self.cMunCarrega = cMunCarrega
        self.validate_TCodMunIBGE(self.cMunCarrega)
        self.xMunCarrega = xMunCarrega
        self.validate_xMunCarregaType(self.xMunCarrega)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infMunCarregaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infMunCarregaType.subclass:
            return infMunCarregaType.subclass(*args_, **kwargs_)
        else:
            return infMunCarregaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cMunCarrega(self): return self.cMunCarrega
    def set_cMunCarrega(self, cMunCarrega): self.cMunCarrega = cMunCarrega
    def get_xMunCarrega(self): return self.xMunCarrega
    def set_xMunCarrega(self, xMunCarrega): self.xMunCarrega = xMunCarrega
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_xMunCarregaType(self, value):
        # Validate type xMunCarregaType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunCarregaType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunCarregaType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunCarregaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunCarregaType_patterns_, ))
    validate_xMunCarregaType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.cMunCarrega is not None or
            self.xMunCarrega is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infMunCarregaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infMunCarregaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infMunCarregaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infMunCarregaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infMunCarregaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infMunCarregaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cMunCarrega is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMunCarrega>%s</cMunCarrega>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMunCarrega), input_name='cMunCarrega')), eol_))
        if self.xMunCarrega is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMunCarrega>%s</xMunCarrega>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMunCarrega), input_name='xMunCarrega')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cMunCarrega':
            cMunCarrega_ = child_.text
            cMunCarrega_ = self.gds_validate_string(cMunCarrega_, node, 'cMunCarrega')
            self.cMunCarrega = cMunCarrega_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunCarrega)
        elif nodeName_ == 'xMunCarrega':
            xMunCarrega_ = child_.text
            xMunCarrega_ = self.gds_validate_string(xMunCarrega_, node, 'xMunCarrega')
            self.xMunCarrega = xMunCarrega_
            # validate type xMunCarregaType
            self.validate_xMunCarregaType(self.xMunCarrega)
# end class infMunCarregaType


class infPercursoType(GeneratedsSuper):
    """Informações do Percurso do MDF-e"""
    subclass = None
    superclass = None
    def __init__(self, UFPer=None):
        self.original_tagname_ = None
        self.UFPer = UFPer
        self.validate_TUf(self.UFPer)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infPercursoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infPercursoType.subclass:
            return infPercursoType.subclass(*args_, **kwargs_)
        else:
            return infPercursoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UFPer(self): return self.UFPer
    def set_UFPer(self, UFPer): self.UFPer = UFPer
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.UFPer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infPercursoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infPercursoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infPercursoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infPercursoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infPercursoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infPercursoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UFPer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UFPer>%s</UFPer>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UFPer), input_name='UFPer')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UFPer':
            UFPer_ = child_.text
            UFPer_ = self.gds_validate_string(UFPer_, node, 'UFPer')
            self.UFPer = UFPer_
            # validate type TUf
            self.validate_TUf(self.UFPer)
# end class infPercursoType


class emitType(GeneratedsSuper):
    """Identificação do Emitente do Manifesto"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, IE=None, xNome=None, xFant=None, enderEmit=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.IE = IE
        self.validate_IEType(self.IE)
        self.xNome = xNome
        self.validate_xNomeType(self.xNome)
        self.xFant = xFant
        self.validate_xFantType(self.xFant)
        self.enderEmit = enderEmit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emitType.subclass:
            return emitType.subclass(*args_, **kwargs_)
        else:
            return emitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_IE(self): return self.IE
    def set_IE(self, IE): self.IE = IE
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_xFant(self): return self.xFant
    def set_xFant(self, xFant): self.xFant = xFant
    def get_enderEmit(self): return self.enderEmit
    def set_enderEmit(self, enderEmit): self.enderEmit = enderEmit
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_IEType(self, value):
        # Validate type IEType, a restriction on TIe.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IEType_patterns_, ))
    validate_IEType_patterns_ = [['^[0-9]{2,14}$']]
    def validate_xNomeType(self, value):
        # Validate type xNomeType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeType_patterns_, ))
    validate_xNomeType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xFantType(self, value):
        # Validate type xFantType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xFantType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xFantType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xFantType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xFantType_patterns_, ))
    validate_xFantType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.IE is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.enderEmit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='emitType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='emitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='emitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='emitType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='emitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IE>%s</IE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xNome>%s</xNome>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), eol_))
        if self.xFant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xFant>%s</xFant>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xFant), input_name='xFant')), eol_))
        if self.enderEmit is not None:
            self.enderEmit.export(outfile, level, namespace_, name_='enderEmit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type IEType
            self.validate_IEType(self.IE)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType
            self.validate_xNomeType(self.xNome)
        elif nodeName_ == 'xFant':
            xFant_ = child_.text
            xFant_ = self.gds_validate_string(xFant_, node, 'xFant')
            self.xFant = xFant_
            # validate type xFantType
            self.validate_xFantType(self.xFant)
        elif nodeName_ == 'enderEmit':
            obj_ = TEndeEmi.factory()
            obj_.build(child_)
            self.enderEmit = obj_
            obj_.original_tagname_ = 'enderEmit'
# end class emitType


class infModalType(GeneratedsSuper):
    """Informações do modal"""
    subclass = None
    superclass = None
    def __init__(self, versaoModal=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.versaoModal = _cast(None, versaoModal)
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infModalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infModalType.subclass:
            return infModalType.subclass(*args_, **kwargs_)
        else:
            return infModalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_versaoModal(self): return self.versaoModal
    def set_versaoModal(self, versaoModal): self.versaoModal = versaoModal
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infModalType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infModalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infModalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infModalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infModalType'):
        if self.versaoModal is not None and 'versaoModal' not in already_processed:
            already_processed.add('versaoModal')
            outfile.write(' versaoModal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.versaoModal), input_name='versaoModal')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='infModalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versaoModal', node)
        if value is not None and 'versaoModal' not in already_processed:
            already_processed.add('versaoModal')
            self.versaoModal = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'infModalType')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class infModalType


class infDocType(GeneratedsSuper):
    """Informações dos Documentos fiscais vinculados ao manifesto"""
    subclass = None
    superclass = None
    def __init__(self, infMunDescarga=None):
        self.original_tagname_ = None
        if infMunDescarga is None:
            self.infMunDescarga = []
        else:
            self.infMunDescarga = infMunDescarga
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infDocType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infDocType.subclass:
            return infDocType.subclass(*args_, **kwargs_)
        else:
            return infDocType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infMunDescarga(self): return self.infMunDescarga
    def set_infMunDescarga(self, infMunDescarga): self.infMunDescarga = infMunDescarga
    def add_infMunDescarga(self, value): self.infMunDescarga.append(value)
    def insert_infMunDescarga_at(self, index, value): self.infMunDescarga.insert(index, value)
    def replace_infMunDescarga_at(self, index, value): self.infMunDescarga[index] = value
    def hasContent_(self):
        if (
            self.infMunDescarga
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infDocType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infDocType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infDocType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infDocType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infDocType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infDocType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for infMunDescarga_ in self.infMunDescarga:
            infMunDescarga_.export(outfile, level, namespace_, name_='infMunDescarga', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infMunDescarga':
            obj_ = infMunDescargaType.factory()
            obj_.build(child_)
            self.infMunDescarga.append(obj_)
            obj_.original_tagname_ = 'infMunDescarga'
# end class infDocType


class infMunDescargaType(GeneratedsSuper):
    """Informações dos Municípios de descarregamento"""
    subclass = None
    superclass = None
    def __init__(self, cMunDescarga=None, xMunDescarga=None, infCTe=None, infNFe=None, infMDFeTransp=None):
        self.original_tagname_ = None
        self.cMunDescarga = cMunDescarga
        self.validate_TCodMunIBGE(self.cMunDescarga)
        self.xMunDescarga = xMunDescarga
        self.validate_xMunDescargaType(self.xMunDescarga)
        if infCTe is None:
            self.infCTe = []
        else:
            self.infCTe = infCTe
        if infNFe is None:
            self.infNFe = []
        else:
            self.infNFe = infNFe
        if infMDFeTransp is None:
            self.infMDFeTransp = []
        else:
            self.infMDFeTransp = infMDFeTransp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infMunDescargaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infMunDescargaType.subclass:
            return infMunDescargaType.subclass(*args_, **kwargs_)
        else:
            return infMunDescargaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cMunDescarga(self): return self.cMunDescarga
    def set_cMunDescarga(self, cMunDescarga): self.cMunDescarga = cMunDescarga
    def get_xMunDescarga(self): return self.xMunDescarga
    def set_xMunDescarga(self, xMunDescarga): self.xMunDescarga = xMunDescarga
    def get_infCTe(self): return self.infCTe
    def set_infCTe(self, infCTe): self.infCTe = infCTe
    def add_infCTe(self, value): self.infCTe.append(value)
    def insert_infCTe_at(self, index, value): self.infCTe.insert(index, value)
    def replace_infCTe_at(self, index, value): self.infCTe[index] = value
    def get_infNFe(self): return self.infNFe
    def set_infNFe(self, infNFe): self.infNFe = infNFe
    def add_infNFe(self, value): self.infNFe.append(value)
    def insert_infNFe_at(self, index, value): self.infNFe.insert(index, value)
    def replace_infNFe_at(self, index, value): self.infNFe[index] = value
    def get_infMDFeTransp(self): return self.infMDFeTransp
    def set_infMDFeTransp(self, infMDFeTransp): self.infMDFeTransp = infMDFeTransp
    def add_infMDFeTransp(self, value): self.infMDFeTransp.append(value)
    def insert_infMDFeTransp_at(self, index, value): self.infMDFeTransp.insert(index, value)
    def replace_infMDFeTransp_at(self, index, value): self.infMDFeTransp[index] = value
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{7}$']]
    def validate_xMunDescargaType(self, value):
        # Validate type xMunDescargaType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunDescargaType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunDescargaType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunDescargaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunDescargaType_patterns_, ))
    validate_xMunDescargaType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.cMunDescarga is not None or
            self.xMunDescarga is not None or
            self.infCTe or
            self.infNFe or
            self.infMDFeTransp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infMunDescargaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infMunDescargaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infMunDescargaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infMunDescargaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infMunDescargaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infMunDescargaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cMunDescarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cMunDescarga>%s</cMunDescarga>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cMunDescarga), input_name='cMunDescarga')), eol_))
        if self.xMunDescarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xMunDescarga>%s</xMunDescarga>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xMunDescarga), input_name='xMunDescarga')), eol_))
        for infCTe_ in self.infCTe:
            infCTe_.export(outfile, level, namespace_, name_='infCTe', pretty_print=pretty_print)
        for infNFe_ in self.infNFe:
            infNFe_.export(outfile, level, namespace_, name_='infNFe', pretty_print=pretty_print)
        for infMDFeTransp_ in self.infMDFeTransp:
            infMDFeTransp_.export(outfile, level, namespace_, name_='infMDFeTransp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cMunDescarga':
            cMunDescarga_ = child_.text
            cMunDescarga_ = self.gds_validate_string(cMunDescarga_, node, 'cMunDescarga')
            self.cMunDescarga = cMunDescarga_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunDescarga)
        elif nodeName_ == 'xMunDescarga':
            xMunDescarga_ = child_.text
            xMunDescarga_ = self.gds_validate_string(xMunDescarga_, node, 'xMunDescarga')
            self.xMunDescarga = xMunDescarga_
            # validate type xMunDescargaType
            self.validate_xMunDescargaType(self.xMunDescarga)
        elif nodeName_ == 'infCTe':
            obj_ = infCTeType.factory()
            obj_.build(child_)
            self.infCTe.append(obj_)
            obj_.original_tagname_ = 'infCTe'
        elif nodeName_ == 'infNFe':
            obj_ = infNFeType.factory()
            obj_.build(child_)
            self.infNFe.append(obj_)
            obj_.original_tagname_ = 'infNFe'
        elif nodeName_ == 'infMDFeTransp':
            obj_ = infMDFeTranspType.factory()
            obj_.build(child_)
            self.infMDFeTransp.append(obj_)
            obj_.original_tagname_ = 'infMDFeTransp'
# end class infMunDescargaType


class infCTeType(GeneratedsSuper):
    """Conhecimentos de Tranporte - usar este grupo quando for prestador de
    serviço de transporte"""
    subclass = None
    superclass = None
    def __init__(self, chCTe=None, SegCodBarra=None, indReentrega=None, infUnidTransp=None, peri=None):
        self.original_tagname_ = None
        self.chCTe = chCTe
        self.validate_TChCTe(self.chCTe)
        self.SegCodBarra = SegCodBarra
        self.validate_TSegCodBarra(self.SegCodBarra)
        self.indReentrega = indReentrega
        self.validate_indReentregaType(self.indReentrega)
        if infUnidTransp is None:
            self.infUnidTransp = []
        else:
            self.infUnidTransp = infUnidTransp
        if peri is None:
            self.peri = []
        else:
            self.peri = peri
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCTeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCTeType.subclass:
            return infCTeType.subclass(*args_, **kwargs_)
        else:
            return infCTeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chCTe(self): return self.chCTe
    def set_chCTe(self, chCTe): self.chCTe = chCTe
    def get_SegCodBarra(self): return self.SegCodBarra
    def set_SegCodBarra(self, SegCodBarra): self.SegCodBarra = SegCodBarra
    def get_indReentrega(self): return self.indReentrega
    def set_indReentrega(self, indReentrega): self.indReentrega = indReentrega
    def get_infUnidTransp(self): return self.infUnidTransp
    def set_infUnidTransp(self, infUnidTransp): self.infUnidTransp = infUnidTransp
    def add_infUnidTransp(self, value): self.infUnidTransp.append(value)
    def insert_infUnidTransp_at(self, index, value): self.infUnidTransp.insert(index, value)
    def replace_infUnidTransp_at(self, index, value): self.infUnidTransp[index] = value
    def get_peri(self): return self.peri
    def set_peri(self, peri): self.peri = peri
    def add_peri(self, value): self.peri.append(value)
    def insert_peri_at(self, index, value): self.peri.insert(index, value)
    def replace_peri_at(self, index, value): self.peri[index] = value
    def validate_TChCTe(self, value):
        # Validate type TChCTe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TChCTe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TChCTe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TChCTe_patterns_, ))
    validate_TChCTe_patterns_ = [['^[0-9]{44}$']]
    def validate_TSegCodBarra(self, value):
        # Validate type TSegCodBarra, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TSegCodBarra_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TSegCodBarra_patterns_, ))
    validate_TSegCodBarra_patterns_ = [['^[0-9]{36}$']]
    def validate_indReentregaType(self, value):
        # Validate type indReentregaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indReentregaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.chCTe is not None or
            self.SegCodBarra is not None or
            self.indReentrega is not None or
            self.infUnidTransp or
            self.peri
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infCTeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCTeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infCTeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infCTeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infCTeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infCTeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCTe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<chCTe>%s</chCTe>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.chCTe), input_name='chCTe')), eol_))
        if self.SegCodBarra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SegCodBarra>%s</SegCodBarra>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SegCodBarra), input_name='SegCodBarra')), eol_))
        if self.indReentrega is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indReentrega>%s</indReentrega>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indReentrega), input_name='indReentrega')), eol_))
        for infUnidTransp_ in self.infUnidTransp:
            infUnidTransp_.export(outfile, level, namespace_, name_='infUnidTransp', pretty_print=pretty_print)
        for peri_ in self.peri:
            peri_.export(outfile, level, namespace_, name_='peri', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chCTe':
            chCTe_ = child_.text
            chCTe_ = self.gds_validate_string(chCTe_, node, 'chCTe')
            self.chCTe = chCTe_
            # validate type TChCTe
            self.validate_TChCTe(self.chCTe)
        elif nodeName_ == 'SegCodBarra':
            SegCodBarra_ = child_.text
            SegCodBarra_ = self.gds_validate_string(SegCodBarra_, node, 'SegCodBarra')
            self.SegCodBarra = SegCodBarra_
            # validate type TSegCodBarra
            self.validate_TSegCodBarra(self.SegCodBarra)
        elif nodeName_ == 'indReentrega':
            indReentrega_ = child_.text
            indReentrega_ = self.gds_validate_string(indReentrega_, node, 'indReentrega')
            self.indReentrega = indReentrega_
            # validate type indReentregaType
            self.validate_indReentregaType(self.indReentrega)
        elif nodeName_ == 'infUnidTransp':
            obj_ = TUnidadeTransp.factory()
            obj_.build(child_)
            self.infUnidTransp.append(obj_)
            obj_.original_tagname_ = 'infUnidTransp'
        elif nodeName_ == 'peri':
            obj_ = periType.factory()
            obj_.build(child_)
            self.peri.append(obj_)
            obj_.original_tagname_ = 'peri'
# end class infCTeType


class periType(GeneratedsSuper):
    """Preenchido quando for  transporte de produtos classificados pela ONU
    como perigosos."""
    subclass = None
    superclass = None
    def __init__(self, nONU=None, xNomeAE=None, xClaRisco=None, grEmb=None, qTotProd=None, qVolTipo=None):
        self.original_tagname_ = None
        self.nONU = nONU
        self.validate_nONUType(self.nONU)
        self.xNomeAE = xNomeAE
        self.validate_xNomeAEType(self.xNomeAE)
        self.xClaRisco = xClaRisco
        self.validate_xClaRiscoType(self.xClaRisco)
        self.grEmb = grEmb
        self.validate_grEmbType(self.grEmb)
        self.qTotProd = qTotProd
        self.validate_qTotProdType(self.qTotProd)
        self.qVolTipo = qVolTipo
        self.validate_qVolTipoType(self.qVolTipo)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, periType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if periType.subclass:
            return periType.subclass(*args_, **kwargs_)
        else:
            return periType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nONU(self): return self.nONU
    def set_nONU(self, nONU): self.nONU = nONU
    def get_xNomeAE(self): return self.xNomeAE
    def set_xNomeAE(self, xNomeAE): self.xNomeAE = xNomeAE
    def get_xClaRisco(self): return self.xClaRisco
    def set_xClaRisco(self, xClaRisco): self.xClaRisco = xClaRisco
    def get_grEmb(self): return self.grEmb
    def set_grEmb(self, grEmb): self.grEmb = grEmb
    def get_qTotProd(self): return self.qTotProd
    def set_qTotProd(self, qTotProd): self.qTotProd = qTotProd
    def get_qVolTipo(self): return self.qVolTipo
    def set_qVolTipo(self, qVolTipo): self.qVolTipo = qVolTipo
    def validate_nONUType(self, value):
        # Validate type nONUType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nONUType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nONUType_patterns_, ))
    validate_nONUType_patterns_ = [['^[0-9]{4}$|^ND$']]
    def validate_xNomeAEType(self, value):
        # Validate type xNomeAEType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 150:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeAEType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeAEType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeAEType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeAEType_patterns_, ))
    validate_xNomeAEType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xClaRiscoType(self, value):
        # Validate type xClaRiscoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xClaRiscoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xClaRiscoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xClaRiscoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xClaRiscoType_patterns_, ))
    validate_xClaRiscoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_grEmbType(self, value):
        # Validate type grEmbType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on grEmbType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on grEmbType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_grEmbType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_grEmbType_patterns_, ))
    validate_grEmbType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_qTotProdType(self, value):
        # Validate type qTotProdType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on qTotProdType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on qTotProdType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_qTotProdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qTotProdType_patterns_, ))
    validate_qTotProdType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_qVolTipoType(self, value):
        # Validate type qVolTipoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on qVolTipoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on qVolTipoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_qVolTipoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qVolTipoType_patterns_, ))
    validate_qVolTipoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.nONU is not None or
            self.xNomeAE is not None or
            self.xClaRisco is not None or
            self.grEmb is not None or
            self.qTotProd is not None or
            self.qVolTipo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='periType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('periType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='periType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='periType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='periType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='periType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nONU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nONU>%s</nONU>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nONU), input_name='nONU')), eol_))
        if self.xNomeAE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xNomeAE>%s</xNomeAE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xNomeAE), input_name='xNomeAE')), eol_))
        if self.xClaRisco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xClaRisco>%s</xClaRisco>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xClaRisco), input_name='xClaRisco')), eol_))
        if self.grEmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<grEmb>%s</grEmb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.grEmb), input_name='grEmb')), eol_))
        if self.qTotProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qTotProd>%s</qTotProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qTotProd), input_name='qTotProd')), eol_))
        if self.qVolTipo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qVolTipo>%s</qVolTipo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qVolTipo), input_name='qVolTipo')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nONU':
            nONU_ = child_.text
            nONU_ = self.gds_validate_string(nONU_, node, 'nONU')
            self.nONU = nONU_
            # validate type nONUType
            self.validate_nONUType(self.nONU)
        elif nodeName_ == 'xNomeAE':
            xNomeAE_ = child_.text
            xNomeAE_ = self.gds_validate_string(xNomeAE_, node, 'xNomeAE')
            self.xNomeAE = xNomeAE_
            # validate type xNomeAEType
            self.validate_xNomeAEType(self.xNomeAE)
        elif nodeName_ == 'xClaRisco':
            xClaRisco_ = child_.text
            xClaRisco_ = self.gds_validate_string(xClaRisco_, node, 'xClaRisco')
            self.xClaRisco = xClaRisco_
            # validate type xClaRiscoType
            self.validate_xClaRiscoType(self.xClaRisco)
        elif nodeName_ == 'grEmb':
            grEmb_ = child_.text
            grEmb_ = self.gds_validate_string(grEmb_, node, 'grEmb')
            self.grEmb = grEmb_
            # validate type grEmbType
            self.validate_grEmbType(self.grEmb)
        elif nodeName_ == 'qTotProd':
            qTotProd_ = child_.text
            qTotProd_ = self.gds_validate_string(qTotProd_, node, 'qTotProd')
            self.qTotProd = qTotProd_
            # validate type qTotProdType
            self.validate_qTotProdType(self.qTotProd)
        elif nodeName_ == 'qVolTipo':
            qVolTipo_ = child_.text
            qVolTipo_ = self.gds_validate_string(qVolTipo_, node, 'qVolTipo')
            self.qVolTipo = qVolTipo_
            # validate type qVolTipoType
            self.validate_qVolTipoType(self.qVolTipo)
# end class periType


class infNFeType(GeneratedsSuper):
    """Informações da NF-e"""
    subclass = None
    superclass = None
    def __init__(self, chNFe=None, SegCodBarra=None, indReentrega=None, infUnidTransp=None, peri=None):
        self.original_tagname_ = None
        self.chNFe = chNFe
        self.validate_TChNFe(self.chNFe)
        self.SegCodBarra = SegCodBarra
        self.validate_TSegCodBarra(self.SegCodBarra)
        self.indReentrega = indReentrega
        self.validate_indReentregaType1(self.indReentrega)
        if infUnidTransp is None:
            self.infUnidTransp = []
        else:
            self.infUnidTransp = infUnidTransp
        if peri is None:
            self.peri = []
        else:
            self.peri = peri
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFeType.subclass:
            return infNFeType.subclass(*args_, **kwargs_)
        else:
            return infNFeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chNFe(self): return self.chNFe
    def set_chNFe(self, chNFe): self.chNFe = chNFe
    def get_SegCodBarra(self): return self.SegCodBarra
    def set_SegCodBarra(self, SegCodBarra): self.SegCodBarra = SegCodBarra
    def get_indReentrega(self): return self.indReentrega
    def set_indReentrega(self, indReentrega): self.indReentrega = indReentrega
    def get_infUnidTransp(self): return self.infUnidTransp
    def set_infUnidTransp(self, infUnidTransp): self.infUnidTransp = infUnidTransp
    def add_infUnidTransp(self, value): self.infUnidTransp.append(value)
    def insert_infUnidTransp_at(self, index, value): self.infUnidTransp.insert(index, value)
    def replace_infUnidTransp_at(self, index, value): self.infUnidTransp[index] = value
    def get_peri(self): return self.peri
    def set_peri(self, peri): self.peri = peri
    def add_peri(self, value): self.peri.append(value)
    def insert_peri_at(self, index, value): self.peri.insert(index, value)
    def replace_peri_at(self, index, value): self.peri[index] = value
    def validate_TChNFe(self, value):
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TChNFe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TChNFe_patterns_, ))
    validate_TChNFe_patterns_ = [['^[0-9]{44}$']]
    def validate_TSegCodBarra(self, value):
        # Validate type TSegCodBarra, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TSegCodBarra_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TSegCodBarra_patterns_, ))
    validate_TSegCodBarra_patterns_ = [['^[0-9]{36}$']]
    def validate_indReentregaType1(self, value):
        # Validate type indReentregaType1, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indReentregaType1' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.chNFe is not None or
            self.SegCodBarra is not None or
            self.indReentrega is not None or
            self.infUnidTransp or
            self.peri
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infNFeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infNFeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infNFeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infNFeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infNFeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<chNFe>%s</chNFe>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.chNFe), input_name='chNFe')), eol_))
        if self.SegCodBarra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SegCodBarra>%s</SegCodBarra>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SegCodBarra), input_name='SegCodBarra')), eol_))
        if self.indReentrega is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indReentrega>%s</indReentrega>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indReentrega), input_name='indReentrega')), eol_))
        for infUnidTransp_ in self.infUnidTransp:
            infUnidTransp_.export(outfile, level, namespace_, name_='infUnidTransp', pretty_print=pretty_print)
        for peri_ in self.peri:
            peri_.export(outfile, level, namespace_, name_='peri', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chNFe':
            chNFe_ = child_.text
            chNFe_ = self.gds_validate_string(chNFe_, node, 'chNFe')
            self.chNFe = chNFe_
            # validate type TChNFe
            self.validate_TChNFe(self.chNFe)
        elif nodeName_ == 'SegCodBarra':
            SegCodBarra_ = child_.text
            SegCodBarra_ = self.gds_validate_string(SegCodBarra_, node, 'SegCodBarra')
            self.SegCodBarra = SegCodBarra_
            # validate type TSegCodBarra
            self.validate_TSegCodBarra(self.SegCodBarra)
        elif nodeName_ == 'indReentrega':
            indReentrega_ = child_.text
            indReentrega_ = self.gds_validate_string(indReentrega_, node, 'indReentrega')
            self.indReentrega = indReentrega_
            # validate type indReentregaType1
            self.validate_indReentregaType1(self.indReentrega)
        elif nodeName_ == 'infUnidTransp':
            obj_ = TUnidadeTransp.factory()
            obj_.build(child_)
            self.infUnidTransp.append(obj_)
            obj_.original_tagname_ = 'infUnidTransp'
        elif nodeName_ == 'peri':
            obj_ = periType2.factory()
            obj_.build(child_)
            self.peri.append(obj_)
            obj_.original_tagname_ = 'peri'
# end class infNFeType


class periType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nONU=None, xNomeAE=None, xClaRisco=None, grEmb=None, qTotProd=None, qVolTipo=None):
        self.original_tagname_ = None
        self.nONU = nONU
        self.validate_nONUType3(self.nONU)
        self.xNomeAE = xNomeAE
        self.validate_xNomeAEType4(self.xNomeAE)
        self.xClaRisco = xClaRisco
        self.validate_xClaRiscoType5(self.xClaRisco)
        self.grEmb = grEmb
        self.validate_grEmbType6(self.grEmb)
        self.qTotProd = qTotProd
        self.validate_qTotProdType7(self.qTotProd)
        self.qVolTipo = qVolTipo
        self.validate_qVolTipoType8(self.qVolTipo)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, periType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if periType2.subclass:
            return periType2.subclass(*args_, **kwargs_)
        else:
            return periType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nONU(self): return self.nONU
    def set_nONU(self, nONU): self.nONU = nONU
    def get_xNomeAE(self): return self.xNomeAE
    def set_xNomeAE(self, xNomeAE): self.xNomeAE = xNomeAE
    def get_xClaRisco(self): return self.xClaRisco
    def set_xClaRisco(self, xClaRisco): self.xClaRisco = xClaRisco
    def get_grEmb(self): return self.grEmb
    def set_grEmb(self, grEmb): self.grEmb = grEmb
    def get_qTotProd(self): return self.qTotProd
    def set_qTotProd(self, qTotProd): self.qTotProd = qTotProd
    def get_qVolTipo(self): return self.qVolTipo
    def set_qVolTipo(self, qVolTipo): self.qVolTipo = qVolTipo
    def validate_nONUType3(self, value):
        # Validate type nONUType3, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nONUType3_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nONUType3_patterns_, ))
    validate_nONUType3_patterns_ = [['^[0-9]{4}$|^ND$']]
    def validate_xNomeAEType4(self, value):
        # Validate type xNomeAEType4, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 150:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeAEType4' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeAEType4' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeAEType4_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeAEType4_patterns_, ))
    validate_xNomeAEType4_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xClaRiscoType5(self, value):
        # Validate type xClaRiscoType5, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xClaRiscoType5' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xClaRiscoType5' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xClaRiscoType5_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xClaRiscoType5_patterns_, ))
    validate_xClaRiscoType5_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_grEmbType6(self, value):
        # Validate type grEmbType6, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on grEmbType6' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on grEmbType6' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_grEmbType6_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_grEmbType6_patterns_, ))
    validate_grEmbType6_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_qTotProdType7(self, value):
        # Validate type qTotProdType7, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on qTotProdType7' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on qTotProdType7' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_qTotProdType7_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qTotProdType7_patterns_, ))
    validate_qTotProdType7_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_qVolTipoType8(self, value):
        # Validate type qVolTipoType8, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on qVolTipoType8' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on qVolTipoType8' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_qVolTipoType8_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qVolTipoType8_patterns_, ))
    validate_qVolTipoType8_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.nONU is not None or
            self.xNomeAE is not None or
            self.xClaRisco is not None or
            self.grEmb is not None or
            self.qTotProd is not None or
            self.qVolTipo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='periType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('periType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='periType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='periType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='periType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='periType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nONU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nONU>%s</nONU>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nONU), input_name='nONU')), eol_))
        if self.xNomeAE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xNomeAE>%s</xNomeAE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xNomeAE), input_name='xNomeAE')), eol_))
        if self.xClaRisco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xClaRisco>%s</xClaRisco>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xClaRisco), input_name='xClaRisco')), eol_))
        if self.grEmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<grEmb>%s</grEmb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.grEmb), input_name='grEmb')), eol_))
        if self.qTotProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qTotProd>%s</qTotProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qTotProd), input_name='qTotProd')), eol_))
        if self.qVolTipo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qVolTipo>%s</qVolTipo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qVolTipo), input_name='qVolTipo')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nONU':
            nONU_ = child_.text
            nONU_ = self.gds_validate_string(nONU_, node, 'nONU')
            self.nONU = nONU_
            # validate type nONUType3
            self.validate_nONUType3(self.nONU)
        elif nodeName_ == 'xNomeAE':
            xNomeAE_ = child_.text
            xNomeAE_ = self.gds_validate_string(xNomeAE_, node, 'xNomeAE')
            self.xNomeAE = xNomeAE_
            # validate type xNomeAEType4
            self.validate_xNomeAEType4(self.xNomeAE)
        elif nodeName_ == 'xClaRisco':
            xClaRisco_ = child_.text
            xClaRisco_ = self.gds_validate_string(xClaRisco_, node, 'xClaRisco')
            self.xClaRisco = xClaRisco_
            # validate type xClaRiscoType5
            self.validate_xClaRiscoType5(self.xClaRisco)
        elif nodeName_ == 'grEmb':
            grEmb_ = child_.text
            grEmb_ = self.gds_validate_string(grEmb_, node, 'grEmb')
            self.grEmb = grEmb_
            # validate type grEmbType6
            self.validate_grEmbType6(self.grEmb)
        elif nodeName_ == 'qTotProd':
            qTotProd_ = child_.text
            qTotProd_ = self.gds_validate_string(qTotProd_, node, 'qTotProd')
            self.qTotProd = qTotProd_
            # validate type qTotProdType7
            self.validate_qTotProdType7(self.qTotProd)
        elif nodeName_ == 'qVolTipo':
            qVolTipo_ = child_.text
            qVolTipo_ = self.gds_validate_string(qVolTipo_, node, 'qVolTipo')
            self.qVolTipo = qVolTipo_
            # validate type qVolTipoType8
            self.validate_qVolTipoType8(self.qVolTipo)
# end class periType2


class infMDFeTranspType(GeneratedsSuper):
    """Manifesto Eletrônico de Documentos Fiscais. Somente para modal
    Aquaviário (vide regras MOC)"""
    subclass = None
    superclass = None
    def __init__(self, chMDFe=None, indReentrega=None, infUnidTransp=None, peri=None):
        self.original_tagname_ = None
        self.chMDFe = chMDFe
        self.validate_TChNFe(self.chMDFe)
        self.indReentrega = indReentrega
        self.validate_indReentregaType9(self.indReentrega)
        if infUnidTransp is None:
            self.infUnidTransp = []
        else:
            self.infUnidTransp = infUnidTransp
        if peri is None:
            self.peri = []
        else:
            self.peri = peri
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infMDFeTranspType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infMDFeTranspType.subclass:
            return infMDFeTranspType.subclass(*args_, **kwargs_)
        else:
            return infMDFeTranspType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chMDFe(self): return self.chMDFe
    def set_chMDFe(self, chMDFe): self.chMDFe = chMDFe
    def get_indReentrega(self): return self.indReentrega
    def set_indReentrega(self, indReentrega): self.indReentrega = indReentrega
    def get_infUnidTransp(self): return self.infUnidTransp
    def set_infUnidTransp(self, infUnidTransp): self.infUnidTransp = infUnidTransp
    def add_infUnidTransp(self, value): self.infUnidTransp.append(value)
    def insert_infUnidTransp_at(self, index, value): self.infUnidTransp.insert(index, value)
    def replace_infUnidTransp_at(self, index, value): self.infUnidTransp[index] = value
    def get_peri(self): return self.peri
    def set_peri(self, peri): self.peri = peri
    def add_peri(self, value): self.peri.append(value)
    def insert_peri_at(self, index, value): self.peri.insert(index, value)
    def replace_peri_at(self, index, value): self.peri[index] = value
    def validate_TChNFe(self, value):
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TChNFe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TChNFe_patterns_, ))
    validate_TChNFe_patterns_ = [['^[0-9]{44}$']]
    def validate_indReentregaType9(self, value):
        # Validate type indReentregaType9, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indReentregaType9' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.chMDFe is not None or
            self.indReentrega is not None or
            self.infUnidTransp or
            self.peri
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infMDFeTranspType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infMDFeTranspType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infMDFeTranspType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infMDFeTranspType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infMDFeTranspType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infMDFeTranspType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chMDFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<chMDFe>%s</chMDFe>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.chMDFe), input_name='chMDFe')), eol_))
        if self.indReentrega is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<indReentrega>%s</indReentrega>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indReentrega), input_name='indReentrega')), eol_))
        for infUnidTransp_ in self.infUnidTransp:
            infUnidTransp_.export(outfile, level, namespace_, name_='infUnidTransp', pretty_print=pretty_print)
        for peri_ in self.peri:
            peri_.export(outfile, level, namespace_, name_='peri', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chMDFe':
            chMDFe_ = child_.text
            chMDFe_ = self.gds_validate_string(chMDFe_, node, 'chMDFe')
            self.chMDFe = chMDFe_
            # validate type TChNFe
            self.validate_TChNFe(self.chMDFe)
        elif nodeName_ == 'indReentrega':
            indReentrega_ = child_.text
            indReentrega_ = self.gds_validate_string(indReentrega_, node, 'indReentrega')
            self.indReentrega = indReentrega_
            # validate type indReentregaType9
            self.validate_indReentregaType9(self.indReentrega)
        elif nodeName_ == 'infUnidTransp':
            obj_ = TUnidadeTransp.factory()
            obj_.build(child_)
            self.infUnidTransp.append(obj_)
            obj_.original_tagname_ = 'infUnidTransp'
        elif nodeName_ == 'peri':
            obj_ = periType10.factory()
            obj_.build(child_)
            self.peri.append(obj_)
            obj_.original_tagname_ = 'peri'
# end class infMDFeTranspType


class periType10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nONU=None, xNomeAE=None, xClaRisco=None, grEmb=None, qTotProd=None, qVolTipo=None):
        self.original_tagname_ = None
        self.nONU = nONU
        self.validate_nONUType11(self.nONU)
        self.xNomeAE = xNomeAE
        self.validate_xNomeAEType12(self.xNomeAE)
        self.xClaRisco = xClaRisco
        self.validate_xClaRiscoType13(self.xClaRisco)
        self.grEmb = grEmb
        self.validate_grEmbType14(self.grEmb)
        self.qTotProd = qTotProd
        self.validate_qTotProdType15(self.qTotProd)
        self.qVolTipo = qVolTipo
        self.validate_qVolTipoType16(self.qVolTipo)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, periType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if periType10.subclass:
            return periType10.subclass(*args_, **kwargs_)
        else:
            return periType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nONU(self): return self.nONU
    def set_nONU(self, nONU): self.nONU = nONU
    def get_xNomeAE(self): return self.xNomeAE
    def set_xNomeAE(self, xNomeAE): self.xNomeAE = xNomeAE
    def get_xClaRisco(self): return self.xClaRisco
    def set_xClaRisco(self, xClaRisco): self.xClaRisco = xClaRisco
    def get_grEmb(self): return self.grEmb
    def set_grEmb(self, grEmb): self.grEmb = grEmb
    def get_qTotProd(self): return self.qTotProd
    def set_qTotProd(self, qTotProd): self.qTotProd = qTotProd
    def get_qVolTipo(self): return self.qVolTipo
    def set_qVolTipo(self, qVolTipo): self.qVolTipo = qVolTipo
    def validate_nONUType11(self, value):
        # Validate type nONUType11, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nONUType11_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nONUType11_patterns_, ))
    validate_nONUType11_patterns_ = [['^[0-9]{4}$|^ND$']]
    def validate_xNomeAEType12(self, value):
        # Validate type xNomeAEType12, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 150:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeAEType12' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeAEType12' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeAEType12_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeAEType12_patterns_, ))
    validate_xNomeAEType12_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_xClaRiscoType13(self, value):
        # Validate type xClaRiscoType13, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xClaRiscoType13' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xClaRiscoType13' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xClaRiscoType13_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xClaRiscoType13_patterns_, ))
    validate_xClaRiscoType13_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_grEmbType14(self, value):
        # Validate type grEmbType14, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on grEmbType14' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on grEmbType14' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_grEmbType14_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_grEmbType14_patterns_, ))
    validate_grEmbType14_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_qTotProdType15(self, value):
        # Validate type qTotProdType15, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on qTotProdType15' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on qTotProdType15' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_qTotProdType15_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qTotProdType15_patterns_, ))
    validate_qTotProdType15_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_qVolTipoType16(self, value):
        # Validate type qVolTipoType16, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on qVolTipoType16' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on qVolTipoType16' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_qVolTipoType16_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qVolTipoType16_patterns_, ))
    validate_qVolTipoType16_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.nONU is not None or
            self.xNomeAE is not None or
            self.xClaRisco is not None or
            self.grEmb is not None or
            self.qTotProd is not None or
            self.qVolTipo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='periType10', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('periType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='periType10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='periType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='periType10'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='periType10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nONU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nONU>%s</nONU>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nONU), input_name='nONU')), eol_))
        if self.xNomeAE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xNomeAE>%s</xNomeAE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xNomeAE), input_name='xNomeAE')), eol_))
        if self.xClaRisco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xClaRisco>%s</xClaRisco>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xClaRisco), input_name='xClaRisco')), eol_))
        if self.grEmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<grEmb>%s</grEmb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.grEmb), input_name='grEmb')), eol_))
        if self.qTotProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qTotProd>%s</qTotProd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qTotProd), input_name='qTotProd')), eol_))
        if self.qVolTipo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qVolTipo>%s</qVolTipo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qVolTipo), input_name='qVolTipo')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nONU':
            nONU_ = child_.text
            nONU_ = self.gds_validate_string(nONU_, node, 'nONU')
            self.nONU = nONU_
            # validate type nONUType11
            self.validate_nONUType11(self.nONU)
        elif nodeName_ == 'xNomeAE':
            xNomeAE_ = child_.text
            xNomeAE_ = self.gds_validate_string(xNomeAE_, node, 'xNomeAE')
            self.xNomeAE = xNomeAE_
            # validate type xNomeAEType12
            self.validate_xNomeAEType12(self.xNomeAE)
        elif nodeName_ == 'xClaRisco':
            xClaRisco_ = child_.text
            xClaRisco_ = self.gds_validate_string(xClaRisco_, node, 'xClaRisco')
            self.xClaRisco = xClaRisco_
            # validate type xClaRiscoType13
            self.validate_xClaRiscoType13(self.xClaRisco)
        elif nodeName_ == 'grEmb':
            grEmb_ = child_.text
            grEmb_ = self.gds_validate_string(grEmb_, node, 'grEmb')
            self.grEmb = grEmb_
            # validate type grEmbType14
            self.validate_grEmbType14(self.grEmb)
        elif nodeName_ == 'qTotProd':
            qTotProd_ = child_.text
            qTotProd_ = self.gds_validate_string(qTotProd_, node, 'qTotProd')
            self.qTotProd = qTotProd_
            # validate type qTotProdType15
            self.validate_qTotProdType15(self.qTotProd)
        elif nodeName_ == 'qVolTipo':
            qVolTipo_ = child_.text
            qVolTipo_ = self.gds_validate_string(qVolTipo_, node, 'qVolTipo')
            self.qVolTipo = qVolTipo_
            # validate type qVolTipoType16
            self.validate_qVolTipoType16(self.qVolTipo)
# end class periType10


class segType(GeneratedsSuper):
    """Informações de Seguro da Carga"""
    subclass = None
    superclass = None
    def __init__(self, infResp=None, infSeg=None, nApol=None, nAver=None):
        self.original_tagname_ = None
        self.infResp = infResp
        self.infSeg = infSeg
        self.nApol = nApol
        self.validate_nApolType(self.nApol)
        if nAver is None:
            self.nAver = []
        else:
            self.nAver = nAver
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, segType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if segType.subclass:
            return segType.subclass(*args_, **kwargs_)
        else:
            return segType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infResp(self): return self.infResp
    def set_infResp(self, infResp): self.infResp = infResp
    def get_infSeg(self): return self.infSeg
    def set_infSeg(self, infSeg): self.infSeg = infSeg
    def get_nApol(self): return self.nApol
    def set_nApol(self, nApol): self.nApol = nApol
    def get_nAver(self): return self.nAver
    def set_nAver(self, nAver): self.nAver = nAver
    def add_nAver(self, value): self.nAver.append(value)
    def insert_nAver_at(self, index, value): self.nAver.insert(index, value)
    def replace_nAver_at(self, index, value): self.nAver[index] = value
    def validate_nApolType(self, value):
        # Validate type nApolType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nApolType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nApolType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nApolType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nApolType_patterns_, ))
    validate_nApolType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nAverType(self, value):
        # Validate type nAverType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nAverType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nAverType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nAverType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nAverType_patterns_, ))
    validate_nAverType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.infResp is not None or
            self.infSeg is not None or
            self.nApol is not None or
            self.nAver
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='segType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('segType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='segType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='segType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='segType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='segType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infResp is not None:
            self.infResp.export(outfile, level, namespace_, name_='infResp', pretty_print=pretty_print)
        if self.infSeg is not None:
            self.infSeg.export(outfile, level, namespace_, name_='infSeg', pretty_print=pretty_print)
        if self.nApol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nApol>%s</nApol>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nApol), input_name='nApol')), eol_))
        for nAver_ in self.nAver:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nAver>%s</nAver>%s' % (self.gds_encode(self.gds_format_string(quote_xml(nAver_), input_name='nAver')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infResp':
            obj_ = infRespType.factory()
            obj_.build(child_)
            self.infResp = obj_
            obj_.original_tagname_ = 'infResp'
        elif nodeName_ == 'infSeg':
            obj_ = infSegType.factory()
            obj_.build(child_)
            self.infSeg = obj_
            obj_.original_tagname_ = 'infSeg'
        elif nodeName_ == 'nApol':
            nApol_ = child_.text
            nApol_ = self.gds_validate_string(nApol_, node, 'nApol')
            self.nApol = nApol_
            # validate type nApolType
            self.validate_nApolType(self.nApol)
        elif nodeName_ == 'nAver':
            nAver_ = child_.text
            nAver_ = self.gds_validate_string(nAver_, node, 'nAver')
            self.nAver.append(nAver_)
            # validate type nAverType
            self.validate_nAverType(self.nAver[-1])
# end class segType


class infRespType(GeneratedsSuper):
    """Informações do responsável pelo seguro da carga"""
    subclass = None
    superclass = None
    def __init__(self, respSeg=None, CNPJ=None, CPF=None):
        self.original_tagname_ = None
        self.respSeg = respSeg
        self.validate_respSegType(self.respSeg)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infRespType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infRespType.subclass:
            return infRespType.subclass(*args_, **kwargs_)
        else:
            return infRespType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_respSeg(self): return self.respSeg
    def set_respSeg(self, respSeg): self.respSeg = respSeg
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def validate_respSegType(self, value):
        # Validate type respSegType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on respSegType' % {"value" : value.encode("utf-8")} )
            if len(value) > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on respSegType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on respSegType' % {"value" : value.encode("utf-8")} )
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]
    def hasContent_(self):
        if (
            self.respSeg is not None or
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infRespType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infRespType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infRespType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infRespType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infRespType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infRespType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.respSeg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<respSeg>%s</respSeg>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.respSeg), input_name='respSeg')), eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPF>%s</CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'respSeg':
            respSeg_ = child_.text
            respSeg_ = self.gds_validate_string(respSeg_, node, 'respSeg')
            self.respSeg = respSeg_
            # validate type respSegType
            self.validate_respSegType(self.respSeg)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
# end class infRespType


class infSegType(GeneratedsSuper):
    """Informações da seguradora"""
    subclass = None
    superclass = None
    def __init__(self, xSeg=None, CNPJ=None):
        self.original_tagname_ = None
        self.xSeg = xSeg
        self.validate_xSegType(self.xSeg)
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infSegType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infSegType.subclass:
            return infSegType.subclass(*args_, **kwargs_)
        else:
            return infSegType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xSeg(self): return self.xSeg
    def set_xSeg(self, xSeg): self.xSeg = xSeg
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def validate_xSegType(self, value):
        # Validate type xSegType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xSegType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xSegType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xSegType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xSegType_patterns_, ))
    validate_xSegType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCnpjOpc(self, value):
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpjOpc_patterns_, ))
    validate_TCnpjOpc_patterns_ = [['^[0-9]{0}$|^[0-9]{14}$']]
    def hasContent_(self):
        if (
            self.xSeg is not None or
            self.CNPJ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infSegType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infSegType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infSegType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infSegType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infSegType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infSegType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xSeg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xSeg>%s</xSeg>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xSeg), input_name='xSeg')), eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xSeg':
            xSeg_ = child_.text
            xSeg_ = self.gds_validate_string(xSeg_, node, 'xSeg')
            self.xSeg = xSeg_
            # validate type xSegType
            self.validate_xSegType(self.xSeg)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
# end class infSegType


class totType(GeneratedsSuper):
    """Totalizadores da carga transportada e seus documentos fiscais"""
    subclass = None
    superclass = None
    def __init__(self, qCTe=None, qNFe=None, qMDFe=None, vCarga=None, cUnid=None, qCarga=None):
        self.original_tagname_ = None
        self.qCTe = qCTe
        self.validate_qCTeType(self.qCTe)
        self.qNFe = qNFe
        self.validate_qNFeType(self.qNFe)
        self.qMDFe = qMDFe
        self.validate_qMDFeType(self.qMDFe)
        self.vCarga = vCarga
        self.validate_TDec_1302(self.vCarga)
        self.cUnid = cUnid
        self.validate_cUnidType(self.cUnid)
        self.qCarga = qCarga
        self.validate_TDec_1104(self.qCarga)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, totType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if totType.subclass:
            return totType.subclass(*args_, **kwargs_)
        else:
            return totType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qCTe(self): return self.qCTe
    def set_qCTe(self, qCTe): self.qCTe = qCTe
    def get_qNFe(self): return self.qNFe
    def set_qNFe(self, qNFe): self.qNFe = qNFe
    def get_qMDFe(self): return self.qMDFe
    def set_qMDFe(self, qMDFe): self.qMDFe = qMDFe
    def get_vCarga(self): return self.vCarga
    def set_vCarga(self, vCarga): self.vCarga = vCarga
    def get_cUnid(self): return self.cUnid
    def set_cUnid(self, cUnid): self.cUnid = cUnid
    def get_qCarga(self): return self.qCarga
    def set_qCarga(self, qCarga): self.qCarga = qCarga
    def validate_qCTeType(self, value):
        # Validate type qCTeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_qCTeType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qCTeType_patterns_, ))
    validate_qCTeType_patterns_ = [['^[0-9]{1,6}$']]
    def validate_qNFeType(self, value):
        # Validate type qNFeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_qNFeType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qNFeType_patterns_, ))
    validate_qNFeType_patterns_ = [['^[0-9]{1,6}$']]
    def validate_qMDFeType(self, value):
        # Validate type qMDFeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_qMDFeType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qMDFeType_patterns_, ))
    validate_qMDFeType_patterns_ = [['^[0-9]{1,6}$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_cUnidType(self, value):
        # Validate type cUnidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cUnidType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [['^0$|^0\\.[0-9]{4}$|^[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]
    def hasContent_(self):
        if (
            self.qCTe is not None or
            self.qNFe is not None or
            self.qMDFe is not None or
            self.vCarga is not None or
            self.cUnid is not None or
            self.qCarga is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='totType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('totType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='totType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='totType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='totType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='totType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qCTe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qCTe>%s</qCTe>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qCTe), input_name='qCTe')), eol_))
        if self.qNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qNFe>%s</qNFe>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qNFe), input_name='qNFe')), eol_))
        if self.qMDFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qMDFe>%s</qMDFe>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qMDFe), input_name='qMDFe')), eol_))
        if self.vCarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vCarga>%s</vCarga>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vCarga), input_name='vCarga')), eol_))
        if self.cUnid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<cUnid>%s</cUnid>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cUnid), input_name='cUnid')), eol_))
        if self.qCarga is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<qCarga>%s</qCarga>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.qCarga), input_name='qCarga')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qCTe':
            qCTe_ = child_.text
            qCTe_ = self.gds_validate_string(qCTe_, node, 'qCTe')
            self.qCTe = qCTe_
            # validate type qCTeType
            self.validate_qCTeType(self.qCTe)
        elif nodeName_ == 'qNFe':
            qNFe_ = child_.text
            qNFe_ = self.gds_validate_string(qNFe_, node, 'qNFe')
            self.qNFe = qNFe_
            # validate type qNFeType
            self.validate_qNFeType(self.qNFe)
        elif nodeName_ == 'qMDFe':
            qMDFe_ = child_.text
            qMDFe_ = self.gds_validate_string(qMDFe_, node, 'qMDFe')
            self.qMDFe = qMDFe_
            # validate type qMDFeType
            self.validate_qMDFeType(self.qMDFe)
        elif nodeName_ == 'vCarga':
            vCarga_ = child_.text
            vCarga_ = self.gds_validate_string(vCarga_, node, 'vCarga')
            self.vCarga = vCarga_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCarga)
        elif nodeName_ == 'cUnid':
            cUnid_ = child_.text
            cUnid_ = self.gds_validate_string(cUnid_, node, 'cUnid')
            self.cUnid = cUnid_
            # validate type cUnidType
            self.validate_cUnidType(self.cUnid)
        elif nodeName_ == 'qCarga':
            qCarga_ = child_.text
            qCarga_ = self.gds_validate_string(qCarga_, node, 'qCarga')
            self.qCarga = qCarga_
            # validate type TDec_1104
            self.validate_TDec_1104(self.qCarga)
# end class totType


class lacresType(GeneratedsSuper):
    """Lacres do MDF-e"""
    subclass = None
    superclass = None
    def __init__(self, nLacre=None):
        self.original_tagname_ = None
        self.nLacre = nLacre
        self.validate_nLacreType(self.nLacre)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacresType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacresType.subclass:
            return lacresType.subclass(*args_, **kwargs_)
        else:
            return lacresType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nLacre(self): return self.nLacre
    def set_nLacre(self, nLacre): self.nLacre = nLacre
    def validate_nLacreType(self, value):
        # Validate type nLacreType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nLacreType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nLacreType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nLacreType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nLacreType_patterns_, ))
    validate_nLacreType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lacresType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacresType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lacresType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='lacresType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lacresType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='lacresType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nLacre>%s</nLacre>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nLacre), input_name='nLacre')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLacre':
            nLacre_ = child_.text
            nLacre_ = self.gds_validate_string(nLacre_, node, 'nLacre')
            self.nLacre = nLacre_
            # validate type nLacreType
            self.validate_nLacreType(self.nLacre)
# end class lacresType


class autXMLType(GeneratedsSuper):
    """Autorizados para download do XML do DF-e"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, autXMLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if autXMLType.subclass:
            return autXMLType.subclass(*args_, **kwargs_)
        else:
            return autXMLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='autXMLType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('autXMLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='autXMLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='autXMLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='autXMLType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='autXMLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPF>%s</CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
# end class autXMLType


class infAdicType(GeneratedsSuper):
    """Informações Adicionais"""
    subclass = None
    superclass = None
    def __init__(self, infAdFisco=None, infCpl=None):
        self.original_tagname_ = None
        self.infAdFisco = infAdFisco
        self.validate_infAdFiscoType(self.infAdFisco)
        self.infCpl = infCpl
        self.validate_infCplType(self.infCpl)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infAdicType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infAdicType.subclass:
            return infAdicType.subclass(*args_, **kwargs_)
        else:
            return infAdicType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infAdFisco(self): return self.infAdFisco
    def set_infAdFisco(self, infAdFisco): self.infAdFisco = infAdFisco
    def get_infCpl(self): return self.infCpl
    def set_infCpl(self, infCpl): self.infCpl = infCpl
    def validate_infAdFiscoType(self, value):
        # Validate type infAdFiscoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on infAdFiscoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on infAdFiscoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_infAdFiscoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_infAdFiscoType_patterns_, ))
    validate_infAdFiscoType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_infCplType(self, value):
        # Validate type infCplType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 5000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on infCplType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on infCplType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_infCplType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_infCplType_patterns_, ))
    validate_infCplType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.infAdFisco is not None or
            self.infCpl is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infAdicType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infAdicType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infAdicType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infAdicType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infAdicType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infAdicType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infAdFisco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<infAdFisco>%s</infAdFisco>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.infAdFisco), input_name='infAdFisco')), eol_))
        if self.infCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<infCpl>%s</infCpl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.infCpl), input_name='infCpl')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infAdFisco':
            infAdFisco_ = child_.text
            infAdFisco_ = self.gds_validate_string(infAdFisco_, node, 'infAdFisco')
            self.infAdFisco = infAdFisco_
            # validate type infAdFiscoType
            self.validate_infAdFiscoType(self.infAdFisco)
        elif nodeName_ == 'infCpl':
            infCpl_ = child_.text
            infCpl_ = self.gds_validate_string(infCpl_, node, 'infCpl')
            self.infCpl = infCpl_
            # validate type infCplType
            self.validate_infCplType(self.infCpl)
# end class infAdicType


class infRecType(GeneratedsSuper):
    """Dados do Recibo do Arquivo"""
    subclass = None
    superclass = None
    def __init__(self, nRec=None, dhRecbto=None, tMed=None):
        self.original_tagname_ = None
        self.nRec = nRec
        self.validate_TRec(self.nRec)
        if isinstance(dhRecbto, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dhRecbto, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dhRecbto
        self.dhRecbto = initvalue_
        self.tMed = tMed
        self.validate_tMedType(self.tMed)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infRecType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infRecType.subclass:
            return infRecType.subclass(*args_, **kwargs_)
        else:
            return infRecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nRec(self): return self.nRec
    def set_nRec(self, nRec): self.nRec = nRec
    def get_dhRecbto(self): return self.dhRecbto
    def set_dhRecbto(self, dhRecbto): self.dhRecbto = dhRecbto
    def get_tMed(self): return self.tMed
    def set_tMed(self, tMed): self.tMed = tMed
    def validate_TRec(self, value):
        # Validate type TRec, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TRec_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TRec_patterns_, ))
    validate_TRec_patterns_ = [['^[0-9]{15}$']]
    def validate_tMedType(self, value):
        # Validate type tMedType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tMedType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tMedType_patterns_, ))
    validate_tMedType_patterns_ = [['^[0-9]{1,4}$']]
    def hasContent_(self):
        if (
            self.nRec is not None or
            self.dhRecbto is not None or
            self.tMed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infRecType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infRecType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infRecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infRecType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infRecType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infRecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nRec>%s</nRec>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nRec), input_name='nRec')), eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dhRecbto>%s</dhRecbto>%s' % (self.gds_format_datetime(self.dhRecbto, input_name='dhRecbto'), eol_))
        if self.tMed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tMed>%s</tMed>%s' % (self.gds_format_integer(self.tMed, input_name='tMed'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nRec':
            nRec_ = child_.text
            nRec_ = self.gds_validate_string(nRec_, node, 'nRec')
            self.nRec = nRec_
            # validate type TRec
            self.validate_TRec(self.nRec)
        elif nodeName_ == 'dhRecbto':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dhRecbto = dval_
        elif nodeName_ == 'tMed':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tMed')
            self.tMed = ival_
            # validate type tMedType
            self.validate_tMedType(self.tMed)
# end class infRecType


class infNFeType51(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, chNFe=None, PIN=None):
        self.original_tagname_ = None
        self.chNFe = chNFe
        self.validate_TChNFe(self.chNFe)
        self.PIN = PIN
        self.validate_TPIN(self.PIN)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFeType51)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFeType51.subclass:
            return infNFeType51.subclass(*args_, **kwargs_)
        else:
            return infNFeType51(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chNFe(self): return self.chNFe
    def set_chNFe(self, chNFe): self.chNFe = chNFe
    def get_PIN(self): return self.PIN
    def set_PIN(self, PIN): self.PIN = PIN
    def validate_TChNFe(self, value):
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TChNFe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TChNFe_patterns_, ))
    validate_TChNFe_patterns_ = [['^[0-9]{44}$']]
    def validate_TPIN(self, value):
        # Validate type TPIN, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TPIN' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TPIN' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TPIN_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TPIN_patterns_, ))
    validate_TPIN_patterns_ = [['^[1-9]{1}[0-9]{1,8}$']]
    def hasContent_(self):
        if (
            self.chNFe is not None or
            self.PIN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infNFeType51', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFeType51')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infNFeType51')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infNFeType51', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infNFeType51'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infNFeType51', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<chNFe>%s</chNFe>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.chNFe), input_name='chNFe')), eol_))
        if self.PIN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PIN>%s</PIN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PIN), input_name='PIN')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chNFe':
            chNFe_ = child_.text
            chNFe_ = self.gds_validate_string(chNFe_, node, 'chNFe')
            self.chNFe = chNFe_
            # validate type TChNFe
            self.validate_TChNFe(self.chNFe)
        elif nodeName_ == 'PIN':
            PIN_ = child_.text
            PIN_ = self.gds_validate_string(PIN_, node, 'PIN')
            self.PIN = PIN_
            # validate type TPIN
            self.validate_TPIN(self.PIN)
# end class infNFeType51


class infNFType(GeneratedsSuper):
    """Informações da NF mod 1 e 1A"""
    subclass = None
    superclass = None
    def __init__(self, emi=None, dest=None, serie=None, nNF=None, dEmi=None, vNF=None, PIN=None):
        self.original_tagname_ = None
        self.emi = emi
        self.dest = dest
        self.serie = serie
        self.validate_serieType(self.serie)
        self.nNF = nNF
        self.validate_nNFType(self.nNF)
        self.dEmi = dEmi
        self.validate_TData(self.dEmi)
        self.vNF = vNF
        self.validate_TDec_1302(self.vNF)
        self.PIN = PIN
        self.validate_TPIN(self.PIN)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFType.subclass:
            return infNFType.subclass(*args_, **kwargs_)
        else:
            return infNFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emi(self): return self.emi
    def set_emi(self, emi): self.emi = emi
    def get_dest(self): return self.dest
    def set_dest(self, dest): self.dest = dest
    def get_serie(self): return self.serie
    def set_serie(self, serie): self.serie = serie
    def get_nNF(self): return self.nNF
    def set_nNF(self, nNF): self.nNF = nNF
    def get_dEmi(self): return self.dEmi
    def set_dEmi(self, dEmi): self.dEmi = dEmi
    def get_vNF(self): return self.vNF
    def set_vNF(self, vNF): self.vNF = vNF
    def get_PIN(self): return self.PIN
    def set_PIN(self, PIN): self.PIN = PIN
    def validate_serieType(self, value):
        # Validate type serieType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on serieType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on serieType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_serieType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_serieType_patterns_, ))
    validate_serieType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_nNFType(self, value):
        # Validate type nNFType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nNFType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nNFType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nNFType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nNFType_patterns_, ))
    validate_nNFType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TPIN(self, value):
        # Validate type TPIN, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TPIN' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TPIN' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TPIN_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TPIN_patterns_, ))
    validate_TPIN_patterns_ = [['^[1-9]{1}[0-9]{1,8}$']]
    def hasContent_(self):
        if (
            self.emi is not None or
            self.dest is not None or
            self.serie is not None or
            self.nNF is not None or
            self.dEmi is not None or
            self.vNF is not None or
            self.PIN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='infNFType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='infNFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='infNFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='infNFType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='infNFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.emi is not None:
            self.emi.export(outfile, level, namespace_, name_='emi', pretty_print=pretty_print)
        if self.dest is not None:
            self.dest.export(outfile, level, namespace_, name_='dest', pretty_print=pretty_print)
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<serie>%s</serie>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), eol_))
        if self.nNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nNF>%s</nNF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nNF), input_name='nNF')), eol_))
        if self.dEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<dEmi>%s</dEmi>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), eol_))
        if self.vNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<vNF>%s</vNF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vNF), input_name='vNF')), eol_))
        if self.PIN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PIN>%s</PIN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PIN), input_name='PIN')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'emi':
            obj_ = emiType.factory()
            obj_.build(child_)
            self.emi = obj_
            obj_.original_tagname_ = 'emi'
        elif nodeName_ == 'dest':
            obj_ = destType.factory()
            obj_.build(child_)
            self.dest = obj_
            obj_.original_tagname_ = 'dest'
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
            # validate type serieType
            self.validate_serieType(self.serie)
        elif nodeName_ == 'nNF':
            nNF_ = child_.text
            nNF_ = self.gds_validate_string(nNF_, node, 'nNF')
            self.nNF = nNF_
            # validate type nNFType
            self.validate_nNFType(self.nNF)
        elif nodeName_ == 'dEmi':
            dEmi_ = child_.text
            dEmi_ = self.gds_validate_string(dEmi_, node, 'dEmi')
            self.dEmi = dEmi_
            # validate type TData
            self.validate_TData(self.dEmi)
        elif nodeName_ == 'vNF':
            vNF_ = child_.text
            vNF_ = self.gds_validate_string(vNF_, node, 'vNF')
            self.vNF = vNF_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vNF)
        elif nodeName_ == 'PIN':
            PIN_ = child_.text
            PIN_ = self.gds_validate_string(PIN_, node, 'PIN')
            self.PIN = PIN_
            # validate type TPIN
            self.validate_TPIN(self.PIN)
# end class infNFType


class emiType(GeneratedsSuper):
    """Informações do Emitente da NF"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, xNome=None, UF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.xNome = xNome
        self.validate_xNomeType52(self.xNome)
        self.UF = UF
        self.validate_TUf(self.UF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emiType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emiType.subclass:
            return emiType.subclass(*args_, **kwargs_)
        else:
            return emiType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_xNomeType52(self, value):
        # Validate type xNomeType52, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeType52' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeType52' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType52_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeType52_patterns_, ))
    validate_xNomeType52_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.xNome is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='emiType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emiType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='emiType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='emiType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='emiType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='emiType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xNome>%s</xNome>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType52
            self.validate_xNomeType52(self.xNome)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
# end class emiType


class destType(GeneratedsSuper):
    """Informações do Destinatário da NF"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, xNome=None, UF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.xNome = xNome
        self.validate_xNomeType53(self.xNome)
        self.UF = UF
        self.validate_TUf(self.UF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, destType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if destType.subclass:
            return destType.subclass(*args_, **kwargs_)
        else:
            return destType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def get_xNome(self): return self.xNome
    def set_xNome(self, xNome): self.xNome = xNome
    def get_UF(self): return self.UF
    def set_UF(self, UF): self.UF = UF
    def validate_TCnpjOpc(self, value):
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpjOpc_patterns_, ))
    validate_TCnpjOpc_patterns_ = [['^[0-9]{0}$|^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]
    def validate_xNomeType53(self, value):
        # Validate type xNomeType53, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeType53' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeType53' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType53_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeType53_patterns_, ))
    validate_xNomeType53_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='destType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('destType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='destType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='destType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='destType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='destType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPF>%s</CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<xNome>%s</xNome>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UF>%s</UF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType53
            self.validate_xNomeType53(self.xNome)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
# end class destType


class lacUnidTranspType(GeneratedsSuper):
    """Lacres das Unidades de Transporte"""
    subclass = None
    superclass = None
    def __init__(self, nLacre=None):
        self.original_tagname_ = None
        self.nLacre = nLacre
        self.validate_nLacreType54(self.nLacre)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacUnidTranspType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacUnidTranspType.subclass:
            return lacUnidTranspType.subclass(*args_, **kwargs_)
        else:
            return lacUnidTranspType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nLacre(self): return self.nLacre
    def set_nLacre(self, nLacre): self.nLacre = nLacre
    def validate_nLacreType54(self, value):
        # Validate type nLacreType54, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nLacreType54' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nLacreType54' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nLacreType54_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nLacreType54_patterns_, ))
    validate_nLacreType54_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lacUnidTranspType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacUnidTranspType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lacUnidTranspType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='lacUnidTranspType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lacUnidTranspType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='lacUnidTranspType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nLacre>%s</nLacre>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nLacre), input_name='nLacre')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLacre':
            nLacre_ = child_.text
            nLacre_ = self.gds_validate_string(nLacre_, node, 'nLacre')
            self.nLacre = nLacre_
            # validate type nLacreType54
            self.validate_nLacreType54(self.nLacre)
# end class lacUnidTranspType


class lacUnidCargaType(GeneratedsSuper):
    """Lacres das Unidades de Carga"""
    subclass = None
    superclass = None
    def __init__(self, nLacre=None):
        self.original_tagname_ = None
        self.nLacre = nLacre
        self.validate_nLacreType55(self.nLacre)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacUnidCargaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacUnidCargaType.subclass:
            return lacUnidCargaType.subclass(*args_, **kwargs_)
        else:
            return lacUnidCargaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nLacre(self): return self.nLacre
    def set_nLacre(self, nLacre): self.nLacre = nLacre
    def validate_nLacreType55(self, value):
        # Validate type nLacreType55, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nLacreType55' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nLacreType55' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nLacreType55_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nLacreType55_patterns_, ))
    validate_nLacreType55_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lacUnidCargaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacUnidCargaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lacUnidCargaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='lacUnidCargaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lacUnidCargaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='lacUnidCargaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<nLacre>%s</nLacre>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.nLacre), input_name='nLacre')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLacre':
            nLacre_ = child_.text
            nLacre_ = self.gds_validate_string(nLacre_, node, 'nLacre')
            self.nLacre = nLacre_
            # validate type nLacreType55
            self.validate_nLacreType55(self.nLacre)
# end class lacUnidCargaType


class CanonicalizationMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CanonicalizationMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CanonicalizationMethodType.subclass:
            return CanonicalizationMethodType.subclass(*args_, **kwargs_)
        else:
            return CanonicalizationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CanonicalizationMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CanonicalizationMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CanonicalizationMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CanonicalizationMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CanonicalizationMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CanonicalizationMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CanonicalizationMethodType


class SignatureMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureMethodType.subclass:
            return SignatureMethodType.subclass(*args_, **kwargs_)
        else:
            return SignatureMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignatureMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignatureMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignatureMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SignatureMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureMethodType


class DigestMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None):
        self.original_tagname_ = None
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigestMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigestMethodType.subclass:
            return DigestMethodType.subclass(*args_, **kwargs_)
        else:
            return DigestMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DigestMethodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DigestMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DigestMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DigestMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DigestMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DigestMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DigestMethodType


GDSClassesMapping = {
    'MDFe': TMDFe,
    'Signature': SignatureType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TMDFe'
        rootClass = TMDFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TMDFe'
        rootClass = TMDFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TMDFe'
        rootClass = TMDFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TMDFe'
        rootClass = TMDFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from mdfe import *\n\n')
        sys.stdout.write('import mdfe as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CanonicalizationMethodType",
    "DigestMethodType",
    "KeyInfoType",
    "ReferenceType",
    "SignatureMethodType",
    "SignatureType",
    "SignatureValueType",
    "SignedInfoType",
    "TEndOrg",
    "TEndReEnt",
    "TEndeEmi",
    "TEnderFer",
    "TEndereco",
    "TEndernac",
    "TEnviMDFe",
    "TLocal",
    "TMDFe",
    "TNFeNF",
    "TRetEnviMDFe",
    "TUnidCarga",
    "TUnidadeTransp",
    "TransformType",
    "TransformsType",
    "X509DataType",
    "autXMLType",
    "destType",
    "emiType",
    "emitType",
    "ideType",
    "infAdicType",
    "infCTeType",
    "infDocType",
    "infMDFeTranspType",
    "infMDFeType",
    "infModalType",
    "infMunCarregaType",
    "infMunDescargaType",
    "infNFType",
    "infNFeType",
    "infNFeType51",
    "infPercursoType",
    "infRecType",
    "infRespType",
    "infSegType",
    "lacUnidCargaType",
    "lacUnidTranspType",
    "lacresType",
    "periType",
    "periType10",
    "periType2",
    "segType",
    "totType"
]
